// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	stderrors "errors"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// HeaderConfig header config
//
// swagger:model HeaderConfig
type HeaderConfig struct {

	// auto link by sku
	AutoLinkBySku *ConfigItemBoolean `json:"AutoLinkBySku,omitempty"`

	// auto populated locations
	AutoPopulatedLocations *ConfigItemBoolean `json:"AutoPopulatedLocations,omitempty"`

	// auto respond cancellation requests
	AutoRespondCancellationRequests *ConfigItemBoolean `json:"AutoRespondCancellationRequests,omitempty"`

	// bopis supported
	BopisSupported *ConfigItemBoolean `json:"BopisSupported,omitempty"`

	// buttons
	// Read Only: true
	Buttons []*ConfigButton `json:"Buttons"`

	// can modify locations on channel
	CanModifyLocationsOnChannel *ConfigItemBoolean `json:"CanModifyLocationsOnChannel,omitempty"`

	// cancellation notes
	CancellationNotes *ConfigItemBoolean `json:"CancellationNotes,omitempty"`

	// cancellation response type
	CancellationResponseType *ConfigPropertySelectionListSelectStringValueOptionString `json:"CancellationResponseType,omitempty"`

	// channel location binding
	ChannelLocationBinding *ConfigChannelLocationBinding `json:"ChannelLocationBinding,omitempty"`

	// channel tag
	ChannelTag *ConfigItemString `json:"ChannelTag,omitempty"`

	// concurrency key
	// Read Only: true
	ConcurrencyKey string `json:"ConcurrencyKey,omitempty"`

	// config discount
	ConfigDiscount *ConfigPropertySelectionListSelectStringValueOptionString `json:"ConfigDiscount,omitempty"`

	// config discount typed
	// Enum: ["AllEvenly","ItemsThenPostage","PostageThenItems"]
	ConfigDiscountTyped string `json:"ConfigDiscountTyped,omitempty"`

	// despatch notes
	DespatchNotes *ConfigItemBoolean `json:"DespatchNotes,omitempty"`

	// display name
	// Read Only: true
	DisplayName string `json:"DisplayName,omitempty"`

	// download refunds
	DownloadRefunds *ConfigItemBoolean `json:"DownloadRefunds,omitempty"`

	// download returns
	DownloadReturns *ConfigItemBoolean `json:"DownloadReturns,omitempty"`

	// dynamic properties
	DynamicProperties []*ConfigItemExternal `json:"DynamicProperties"`

	// enabled
	Enabled *ConfigItemBoolean `json:"Enabled,omitempty"`

	// end when
	EndWhen *ConfigItemInt32 `json:"EndWhen,omitempty"`

	// estimated inventory scan complete
	EstimatedInventoryScanComplete *ConfigItemDateTime `json:"EstimatedInventoryScanComplete,omitempty"`

	// extract inventory
	ExtractInventory *ConfigPropertyBoolean `json:"ExtractInventory,omitempty"`

	// extract inventory variation mapping property name
	ExtractInventoryVariationMappingPropertyName *ConfigPropertyString `json:"ExtractInventoryVariationMappingPropertyName,omitempty"`

	// fulfillment location
	// Example: 00000000-0000-0000-0000-000000000000
	// Read Only: true
	// Format: uuid
	FulfillmentLocation strfmt.UUID `json:"FulfillmentLocation,omitempty"`

	// fulfillment service enabled
	// Read Only: true
	FulfillmentServiceEnabled *bool `json:"FulfillmentServiceEnabled,omitempty"`

	// header audit values
	// Read Only: true
	HeaderAuditValues []*ChannelSettingAudit `json:"HeaderAuditValues"`

	// hides header attributes
	HidesHeaderAttributes *ConfigPropertyBoolean `json:"HidesHeaderAttributes,omitempty"`

	// inv sync error count
	InvSyncErrorCount *ConfigItemInt32 `json:"InvSyncErrorCount,omitempty"`

	// inventory sync
	InventorySync *ConfigItemBoolean `json:"InventorySync,omitempty"`

	// is header only
	// Read Only: true
	IsHeaderOnly *bool `json:"IsHeaderOnly,omitempty"`

	// is hidden
	IsHidden bool `json:"IsHidden,omitempty"`

	// is inventory sync trigger enabled
	IsInventorySyncTriggerEnabled *ConfigPropertyBoolean `json:"IsInventorySyncTriggerEnabled,omitempty"`

	// is listing scan running
	IsListingScanRunning *ConfigItemBoolean `json:"IsListingScanRunning,omitempty"`

	// is multi location
	IsMultiLocation *ConfigItemBoolean `json:"IsMultiLocation,omitempty"`

	// is orders site specific
	IsOrdersSiteSpecific *ConfigItemBoolean `json:"IsOrdersSiteSpecific,omitempty"`

	// last listing update date
	LastListingUpdateDate *ConfigItemDateTime `json:"LastListingUpdateDate,omitempty"`

	// listing scan start update date
	ListingScanStartUpdateDate *ConfigItemDateTime `json:"ListingScanStartUpdateDate,omitempty"`

	// max listed
	MaxListed *ConfigItemInt32 `json:"MaxListed,omitempty"`

	// order cancellation check date
	OrderCancellationCheckDate *ConfigItemDateTime `json:"OrderCancellationCheckDate,omitempty"`

	// order cancellation check error count
	OrderCancellationCheckErrorCount *ConfigItemInt32 `json:"OrderCancellationCheckErrorCount,omitempty"`

	// order cancellation check global error count
	OrderCancellationCheckGlobalErrorCount *ConfigItemInt32 `json:"OrderCancellationCheckGlobalErrorCount,omitempty"`

	// order despatch error count
	OrderDespatchErrorCount *ConfigItemInt32 `json:"OrderDespatchErrorCount,omitempty"`

	// order despatch global error count
	OrderDespatchGlobalErrorCount *ConfigItemInt32 `json:"OrderDespatchGlobalErrorCount,omitempty"`

	// order download error count
	OrderDownloadErrorCount *ConfigItemInt32 `json:"OrderDownloadErrorCount,omitempty"`

	// order download global error count
	OrderDownloadGlobalErrorCount *ConfigItemInt32 `json:"OrderDownloadGlobalErrorCount,omitempty"`

	// order save location
	OrderSaveLocation *ConfigPropertySelectionListSelectStringValueOptionGUID `json:"OrderSaveLocation,omitempty"`

	// order sync date
	OrderSyncDate *ConfigItemDateTime `json:"OrderSyncDate,omitempty"`

	// payment method mapping
	PaymentMethodMapping *ConfigPaymentMethodMapping `json:"PaymentMethodMapping,omitempty"`

	// pk channel Id
	PkChannelID int32 `json:"PkChannelId,omitempty"`

	// postal service mapping
	PostalServiceMapping *ConfigPostalServiceMapping `json:"PostalServiceMapping,omitempty"`

	// price change
	PriceChange *ConfigItemBoolean `json:"PriceChange,omitempty"`

	// price change error count
	PriceChangeErrorCount *ConfigItemInt32 `json:"PriceChangeErrorCount,omitempty"`

	// process pos orders
	ProcessPosOrders *ConfigPropertyBoolean `json:"ProcessPosOrders,omitempty"`

	// refund notes
	RefundNotes *ConfigItemBoolean `json:"RefundNotes,omitempty"`

	// return notes
	ReturnNotes *ConfigItemBoolean `json:"ReturnNotes,omitempty"`

	// rma download error count
	RmaDownloadErrorCount *ConfigItemInt32 `json:"RmaDownloadErrorCount,omitempty"`

	// rma download global error count
	RmaDownloadGlobalErrorCount *ConfigItemInt32 `json:"RmaDownloadGlobalErrorCount,omitempty"`

	// rules
	// Read Only: true
	Rules []*ConfigRule `json:"Rules"`

	// source
	// Read Only: true
	Source string `json:"Source,omitempty"`

	// source type
	// Read Only: true
	SourceType string `json:"SourceType,omitempty"`

	// source version
	SourceVersion *ConfigItemString `json:"SourceVersion,omitempty"`

	// stock location binding
	StockLocationBinding *ConfigStockLocationBinding `json:"StockLocationBinding,omitempty"`

	// stock percentage
	StockPercentage *ConfigItemDouble `json:"StockPercentage,omitempty"`

	// sub source
	SubSource string `json:"SubSource,omitempty"`
}

// Validate validates this header config
func (m *HeaderConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAutoLinkBySku(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutoPopulatedLocations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutoRespondCancellationRequests(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBopisSupported(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateButtons(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCanModifyLocationsOnChannel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCancellationNotes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCancellationResponseType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChannelLocationBinding(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChannelTag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigDiscountTyped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDespatchNotes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDownloadRefunds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDownloadReturns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDynamicProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndWhen(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEstimatedInventoryScanComplete(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExtractInventory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExtractInventoryVariationMappingPropertyName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFulfillmentLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeaderAuditValues(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHidesHeaderAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvSyncErrorCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInventorySync(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsInventorySyncTriggerEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsListingScanRunning(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsMultiLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsOrdersSiteSpecific(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastListingUpdateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateListingScanStartUpdateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxListed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderCancellationCheckDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderCancellationCheckErrorCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderCancellationCheckGlobalErrorCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderDespatchErrorCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderDespatchGlobalErrorCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderDownloadErrorCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderDownloadGlobalErrorCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderSaveLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderSyncDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentMethodMapping(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostalServiceMapping(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePriceChange(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePriceChangeErrorCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessPosOrders(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRefundNotes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReturnNotes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRmaDownloadErrorCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRmaDownloadGlobalErrorCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRules(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStockLocationBinding(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStockPercentage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HeaderConfig) validateAutoLinkBySku(formats strfmt.Registry) error {
	if swag.IsZero(m.AutoLinkBySku) { // not required
		return nil
	}

	if m.AutoLinkBySku != nil {
		if err := m.AutoLinkBySku.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("AutoLinkBySku")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("AutoLinkBySku")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateAutoPopulatedLocations(formats strfmt.Registry) error {
	if swag.IsZero(m.AutoPopulatedLocations) { // not required
		return nil
	}

	if m.AutoPopulatedLocations != nil {
		if err := m.AutoPopulatedLocations.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("AutoPopulatedLocations")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("AutoPopulatedLocations")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateAutoRespondCancellationRequests(formats strfmt.Registry) error {
	if swag.IsZero(m.AutoRespondCancellationRequests) { // not required
		return nil
	}

	if m.AutoRespondCancellationRequests != nil {
		if err := m.AutoRespondCancellationRequests.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("AutoRespondCancellationRequests")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("AutoRespondCancellationRequests")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateBopisSupported(formats strfmt.Registry) error {
	if swag.IsZero(m.BopisSupported) { // not required
		return nil
	}

	if m.BopisSupported != nil {
		if err := m.BopisSupported.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("BopisSupported")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("BopisSupported")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateButtons(formats strfmt.Registry) error {
	if swag.IsZero(m.Buttons) { // not required
		return nil
	}

	for i := 0; i < len(m.Buttons); i++ {
		if swag.IsZero(m.Buttons[i]) { // not required
			continue
		}

		if m.Buttons[i] != nil {
			if err := m.Buttons[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Buttons" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Buttons" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *HeaderConfig) validateCanModifyLocationsOnChannel(formats strfmt.Registry) error {
	if swag.IsZero(m.CanModifyLocationsOnChannel) { // not required
		return nil
	}

	if m.CanModifyLocationsOnChannel != nil {
		if err := m.CanModifyLocationsOnChannel.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("CanModifyLocationsOnChannel")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("CanModifyLocationsOnChannel")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateCancellationNotes(formats strfmt.Registry) error {
	if swag.IsZero(m.CancellationNotes) { // not required
		return nil
	}

	if m.CancellationNotes != nil {
		if err := m.CancellationNotes.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("CancellationNotes")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("CancellationNotes")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateCancellationResponseType(formats strfmt.Registry) error {
	if swag.IsZero(m.CancellationResponseType) { // not required
		return nil
	}

	if m.CancellationResponseType != nil {
		if err := m.CancellationResponseType.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("CancellationResponseType")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("CancellationResponseType")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateChannelLocationBinding(formats strfmt.Registry) error {
	if swag.IsZero(m.ChannelLocationBinding) { // not required
		return nil
	}

	if m.ChannelLocationBinding != nil {
		if err := m.ChannelLocationBinding.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ChannelLocationBinding")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ChannelLocationBinding")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateChannelTag(formats strfmt.Registry) error {
	if swag.IsZero(m.ChannelTag) { // not required
		return nil
	}

	if m.ChannelTag != nil {
		if err := m.ChannelTag.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ChannelTag")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ChannelTag")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateConfigDiscount(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigDiscount) { // not required
		return nil
	}

	if m.ConfigDiscount != nil {
		if err := m.ConfigDiscount.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ConfigDiscount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ConfigDiscount")
			}

			return err
		}
	}

	return nil
}

var headerConfigTypeConfigDiscountTypedPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["AllEvenly","ItemsThenPostage","PostageThenItems"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		headerConfigTypeConfigDiscountTypedPropEnum = append(headerConfigTypeConfigDiscountTypedPropEnum, v)
	}
}

const (

	// HeaderConfigConfigDiscountTypedAllEvenly captures enum value "AllEvenly"
	HeaderConfigConfigDiscountTypedAllEvenly string = "AllEvenly"

	// HeaderConfigConfigDiscountTypedItemsThenPostage captures enum value "ItemsThenPostage"
	HeaderConfigConfigDiscountTypedItemsThenPostage string = "ItemsThenPostage"

	// HeaderConfigConfigDiscountTypedPostageThenItems captures enum value "PostageThenItems"
	HeaderConfigConfigDiscountTypedPostageThenItems string = "PostageThenItems"
)

// prop value enum
func (m *HeaderConfig) validateConfigDiscountTypedEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, headerConfigTypeConfigDiscountTypedPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HeaderConfig) validateConfigDiscountTyped(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigDiscountTyped) { // not required
		return nil
	}

	// value enum
	if err := m.validateConfigDiscountTypedEnum("ConfigDiscountTyped", "body", m.ConfigDiscountTyped); err != nil {
		return err
	}

	return nil
}

func (m *HeaderConfig) validateDespatchNotes(formats strfmt.Registry) error {
	if swag.IsZero(m.DespatchNotes) { // not required
		return nil
	}

	if m.DespatchNotes != nil {
		if err := m.DespatchNotes.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("DespatchNotes")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("DespatchNotes")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateDownloadRefunds(formats strfmt.Registry) error {
	if swag.IsZero(m.DownloadRefunds) { // not required
		return nil
	}

	if m.DownloadRefunds != nil {
		if err := m.DownloadRefunds.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("DownloadRefunds")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("DownloadRefunds")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateDownloadReturns(formats strfmt.Registry) error {
	if swag.IsZero(m.DownloadReturns) { // not required
		return nil
	}

	if m.DownloadReturns != nil {
		if err := m.DownloadReturns.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("DownloadReturns")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("DownloadReturns")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateDynamicProperties(formats strfmt.Registry) error {
	if swag.IsZero(m.DynamicProperties) { // not required
		return nil
	}

	for i := 0; i < len(m.DynamicProperties); i++ {
		if swag.IsZero(m.DynamicProperties[i]) { // not required
			continue
		}

		if m.DynamicProperties[i] != nil {
			if err := m.DynamicProperties[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("DynamicProperties" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("DynamicProperties" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *HeaderConfig) validateEnabled(formats strfmt.Registry) error {
	if swag.IsZero(m.Enabled) { // not required
		return nil
	}

	if m.Enabled != nil {
		if err := m.Enabled.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("Enabled")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("Enabled")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateEndWhen(formats strfmt.Registry) error {
	if swag.IsZero(m.EndWhen) { // not required
		return nil
	}

	if m.EndWhen != nil {
		if err := m.EndWhen.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("EndWhen")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("EndWhen")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateEstimatedInventoryScanComplete(formats strfmt.Registry) error {
	if swag.IsZero(m.EstimatedInventoryScanComplete) { // not required
		return nil
	}

	if m.EstimatedInventoryScanComplete != nil {
		if err := m.EstimatedInventoryScanComplete.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("EstimatedInventoryScanComplete")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("EstimatedInventoryScanComplete")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateExtractInventory(formats strfmt.Registry) error {
	if swag.IsZero(m.ExtractInventory) { // not required
		return nil
	}

	if m.ExtractInventory != nil {
		if err := m.ExtractInventory.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ExtractInventory")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ExtractInventory")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateExtractInventoryVariationMappingPropertyName(formats strfmt.Registry) error {
	if swag.IsZero(m.ExtractInventoryVariationMappingPropertyName) { // not required
		return nil
	}

	if m.ExtractInventoryVariationMappingPropertyName != nil {
		if err := m.ExtractInventoryVariationMappingPropertyName.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ExtractInventoryVariationMappingPropertyName")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ExtractInventoryVariationMappingPropertyName")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateFulfillmentLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.FulfillmentLocation) { // not required
		return nil
	}

	if err := validate.FormatOf("FulfillmentLocation", "body", "uuid", m.FulfillmentLocation.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *HeaderConfig) validateHeaderAuditValues(formats strfmt.Registry) error {
	if swag.IsZero(m.HeaderAuditValues) { // not required
		return nil
	}

	for i := 0; i < len(m.HeaderAuditValues); i++ {
		if swag.IsZero(m.HeaderAuditValues[i]) { // not required
			continue
		}

		if m.HeaderAuditValues[i] != nil {
			if err := m.HeaderAuditValues[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("HeaderAuditValues" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("HeaderAuditValues" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *HeaderConfig) validateHidesHeaderAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.HidesHeaderAttributes) { // not required
		return nil
	}

	if m.HidesHeaderAttributes != nil {
		if err := m.HidesHeaderAttributes.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("HidesHeaderAttributes")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("HidesHeaderAttributes")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateInvSyncErrorCount(formats strfmt.Registry) error {
	if swag.IsZero(m.InvSyncErrorCount) { // not required
		return nil
	}

	if m.InvSyncErrorCount != nil {
		if err := m.InvSyncErrorCount.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("InvSyncErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("InvSyncErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateInventorySync(formats strfmt.Registry) error {
	if swag.IsZero(m.InventorySync) { // not required
		return nil
	}

	if m.InventorySync != nil {
		if err := m.InventorySync.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("InventorySync")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("InventorySync")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateIsInventorySyncTriggerEnabled(formats strfmt.Registry) error {
	if swag.IsZero(m.IsInventorySyncTriggerEnabled) { // not required
		return nil
	}

	if m.IsInventorySyncTriggerEnabled != nil {
		if err := m.IsInventorySyncTriggerEnabled.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("IsInventorySyncTriggerEnabled")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("IsInventorySyncTriggerEnabled")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateIsListingScanRunning(formats strfmt.Registry) error {
	if swag.IsZero(m.IsListingScanRunning) { // not required
		return nil
	}

	if m.IsListingScanRunning != nil {
		if err := m.IsListingScanRunning.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("IsListingScanRunning")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("IsListingScanRunning")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateIsMultiLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.IsMultiLocation) { // not required
		return nil
	}

	if m.IsMultiLocation != nil {
		if err := m.IsMultiLocation.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("IsMultiLocation")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("IsMultiLocation")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateIsOrdersSiteSpecific(formats strfmt.Registry) error {
	if swag.IsZero(m.IsOrdersSiteSpecific) { // not required
		return nil
	}

	if m.IsOrdersSiteSpecific != nil {
		if err := m.IsOrdersSiteSpecific.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("IsOrdersSiteSpecific")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("IsOrdersSiteSpecific")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateLastListingUpdateDate(formats strfmt.Registry) error {
	if swag.IsZero(m.LastListingUpdateDate) { // not required
		return nil
	}

	if m.LastListingUpdateDate != nil {
		if err := m.LastListingUpdateDate.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("LastListingUpdateDate")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("LastListingUpdateDate")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateListingScanStartUpdateDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ListingScanStartUpdateDate) { // not required
		return nil
	}

	if m.ListingScanStartUpdateDate != nil {
		if err := m.ListingScanStartUpdateDate.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ListingScanStartUpdateDate")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ListingScanStartUpdateDate")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateMaxListed(formats strfmt.Registry) error {
	if swag.IsZero(m.MaxListed) { // not required
		return nil
	}

	if m.MaxListed != nil {
		if err := m.MaxListed.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("MaxListed")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("MaxListed")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateOrderCancellationCheckDate(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderCancellationCheckDate) { // not required
		return nil
	}

	if m.OrderCancellationCheckDate != nil {
		if err := m.OrderCancellationCheckDate.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderCancellationCheckDate")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderCancellationCheckDate")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateOrderCancellationCheckErrorCount(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderCancellationCheckErrorCount) { // not required
		return nil
	}

	if m.OrderCancellationCheckErrorCount != nil {
		if err := m.OrderCancellationCheckErrorCount.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderCancellationCheckErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderCancellationCheckErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateOrderCancellationCheckGlobalErrorCount(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderCancellationCheckGlobalErrorCount) { // not required
		return nil
	}

	if m.OrderCancellationCheckGlobalErrorCount != nil {
		if err := m.OrderCancellationCheckGlobalErrorCount.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderCancellationCheckGlobalErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderCancellationCheckGlobalErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateOrderDespatchErrorCount(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderDespatchErrorCount) { // not required
		return nil
	}

	if m.OrderDespatchErrorCount != nil {
		if err := m.OrderDespatchErrorCount.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderDespatchErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderDespatchErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateOrderDespatchGlobalErrorCount(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderDespatchGlobalErrorCount) { // not required
		return nil
	}

	if m.OrderDespatchGlobalErrorCount != nil {
		if err := m.OrderDespatchGlobalErrorCount.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderDespatchGlobalErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderDespatchGlobalErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateOrderDownloadErrorCount(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderDownloadErrorCount) { // not required
		return nil
	}

	if m.OrderDownloadErrorCount != nil {
		if err := m.OrderDownloadErrorCount.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderDownloadErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderDownloadErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateOrderDownloadGlobalErrorCount(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderDownloadGlobalErrorCount) { // not required
		return nil
	}

	if m.OrderDownloadGlobalErrorCount != nil {
		if err := m.OrderDownloadGlobalErrorCount.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderDownloadGlobalErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderDownloadGlobalErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateOrderSaveLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderSaveLocation) { // not required
		return nil
	}

	if m.OrderSaveLocation != nil {
		if err := m.OrderSaveLocation.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderSaveLocation")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderSaveLocation")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateOrderSyncDate(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderSyncDate) { // not required
		return nil
	}

	if m.OrderSyncDate != nil {
		if err := m.OrderSyncDate.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderSyncDate")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderSyncDate")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validatePaymentMethodMapping(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentMethodMapping) { // not required
		return nil
	}

	if m.PaymentMethodMapping != nil {
		if err := m.PaymentMethodMapping.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("PaymentMethodMapping")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("PaymentMethodMapping")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validatePostalServiceMapping(formats strfmt.Registry) error {
	if swag.IsZero(m.PostalServiceMapping) { // not required
		return nil
	}

	if m.PostalServiceMapping != nil {
		if err := m.PostalServiceMapping.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("PostalServiceMapping")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("PostalServiceMapping")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validatePriceChange(formats strfmt.Registry) error {
	if swag.IsZero(m.PriceChange) { // not required
		return nil
	}

	if m.PriceChange != nil {
		if err := m.PriceChange.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("PriceChange")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("PriceChange")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validatePriceChangeErrorCount(formats strfmt.Registry) error {
	if swag.IsZero(m.PriceChangeErrorCount) { // not required
		return nil
	}

	if m.PriceChangeErrorCount != nil {
		if err := m.PriceChangeErrorCount.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("PriceChangeErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("PriceChangeErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateProcessPosOrders(formats strfmt.Registry) error {
	if swag.IsZero(m.ProcessPosOrders) { // not required
		return nil
	}

	if m.ProcessPosOrders != nil {
		if err := m.ProcessPosOrders.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ProcessPosOrders")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ProcessPosOrders")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateRefundNotes(formats strfmt.Registry) error {
	if swag.IsZero(m.RefundNotes) { // not required
		return nil
	}

	if m.RefundNotes != nil {
		if err := m.RefundNotes.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("RefundNotes")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("RefundNotes")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateReturnNotes(formats strfmt.Registry) error {
	if swag.IsZero(m.ReturnNotes) { // not required
		return nil
	}

	if m.ReturnNotes != nil {
		if err := m.ReturnNotes.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ReturnNotes")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ReturnNotes")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateRmaDownloadErrorCount(formats strfmt.Registry) error {
	if swag.IsZero(m.RmaDownloadErrorCount) { // not required
		return nil
	}

	if m.RmaDownloadErrorCount != nil {
		if err := m.RmaDownloadErrorCount.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("RmaDownloadErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("RmaDownloadErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateRmaDownloadGlobalErrorCount(formats strfmt.Registry) error {
	if swag.IsZero(m.RmaDownloadGlobalErrorCount) { // not required
		return nil
	}

	if m.RmaDownloadGlobalErrorCount != nil {
		if err := m.RmaDownloadGlobalErrorCount.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("RmaDownloadGlobalErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("RmaDownloadGlobalErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateRules(formats strfmt.Registry) error {
	if swag.IsZero(m.Rules) { // not required
		return nil
	}

	for i := 0; i < len(m.Rules); i++ {
		if swag.IsZero(m.Rules[i]) { // not required
			continue
		}

		if m.Rules[i] != nil {
			if err := m.Rules[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Rules" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Rules" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *HeaderConfig) validateSourceVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.SourceVersion) { // not required
		return nil
	}

	if m.SourceVersion != nil {
		if err := m.SourceVersion.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("SourceVersion")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("SourceVersion")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateStockLocationBinding(formats strfmt.Registry) error {
	if swag.IsZero(m.StockLocationBinding) { // not required
		return nil
	}

	if m.StockLocationBinding != nil {
		if err := m.StockLocationBinding.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("StockLocationBinding")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("StockLocationBinding")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) validateStockPercentage(formats strfmt.Registry) error {
	if swag.IsZero(m.StockPercentage) { // not required
		return nil
	}

	if m.StockPercentage != nil {
		if err := m.StockPercentage.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("StockPercentage")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("StockPercentage")
			}

			return err
		}
	}

	return nil
}

// ContextValidate validate this header config based on the context it is used
func (m *HeaderConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAutoLinkBySku(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAutoPopulatedLocations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAutoRespondCancellationRequests(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBopisSupported(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateButtons(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCanModifyLocationsOnChannel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCancellationNotes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCancellationResponseType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateChannelLocationBinding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateChannelTag(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConcurrencyKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigDiscount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDespatchNotes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDisplayName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDownloadRefunds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDownloadReturns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDynamicProperties(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEndWhen(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEstimatedInventoryScanComplete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExtractInventory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExtractInventoryVariationMappingPropertyName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFulfillmentLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFulfillmentServiceEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeaderAuditValues(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHidesHeaderAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInvSyncErrorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInventorySync(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsHeaderOnly(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsInventorySyncTriggerEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsListingScanRunning(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsMultiLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsOrdersSiteSpecific(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastListingUpdateDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateListingScanStartUpdateDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxListed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrderCancellationCheckDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrderCancellationCheckErrorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrderCancellationCheckGlobalErrorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrderDespatchErrorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrderDespatchGlobalErrorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrderDownloadErrorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrderDownloadGlobalErrorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrderSaveLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrderSyncDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePaymentMethodMapping(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePostalServiceMapping(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePriceChange(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePriceChangeErrorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProcessPosOrders(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRefundNotes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReturnNotes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRmaDownloadErrorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRmaDownloadGlobalErrorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStockLocationBinding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStockPercentage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HeaderConfig) contextValidateAutoLinkBySku(ctx context.Context, formats strfmt.Registry) error {

	if m.AutoLinkBySku != nil {

		if swag.IsZero(m.AutoLinkBySku) { // not required
			return nil
		}

		if err := m.AutoLinkBySku.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("AutoLinkBySku")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("AutoLinkBySku")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateAutoPopulatedLocations(ctx context.Context, formats strfmt.Registry) error {

	if m.AutoPopulatedLocations != nil {

		if swag.IsZero(m.AutoPopulatedLocations) { // not required
			return nil
		}

		if err := m.AutoPopulatedLocations.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("AutoPopulatedLocations")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("AutoPopulatedLocations")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateAutoRespondCancellationRequests(ctx context.Context, formats strfmt.Registry) error {

	if m.AutoRespondCancellationRequests != nil {

		if swag.IsZero(m.AutoRespondCancellationRequests) { // not required
			return nil
		}

		if err := m.AutoRespondCancellationRequests.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("AutoRespondCancellationRequests")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("AutoRespondCancellationRequests")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateBopisSupported(ctx context.Context, formats strfmt.Registry) error {

	if m.BopisSupported != nil {

		if swag.IsZero(m.BopisSupported) { // not required
			return nil
		}

		if err := m.BopisSupported.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("BopisSupported")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("BopisSupported")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateButtons(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "Buttons", "body", m.Buttons); err != nil {
		return err
	}

	for i := 0; i < len(m.Buttons); i++ {

		if m.Buttons[i] != nil {

			if swag.IsZero(m.Buttons[i]) { // not required
				return nil
			}

			if err := m.Buttons[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Buttons" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Buttons" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *HeaderConfig) contextValidateCanModifyLocationsOnChannel(ctx context.Context, formats strfmt.Registry) error {

	if m.CanModifyLocationsOnChannel != nil {

		if swag.IsZero(m.CanModifyLocationsOnChannel) { // not required
			return nil
		}

		if err := m.CanModifyLocationsOnChannel.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("CanModifyLocationsOnChannel")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("CanModifyLocationsOnChannel")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateCancellationNotes(ctx context.Context, formats strfmt.Registry) error {

	if m.CancellationNotes != nil {

		if swag.IsZero(m.CancellationNotes) { // not required
			return nil
		}

		if err := m.CancellationNotes.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("CancellationNotes")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("CancellationNotes")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateCancellationResponseType(ctx context.Context, formats strfmt.Registry) error {

	if m.CancellationResponseType != nil {

		if swag.IsZero(m.CancellationResponseType) { // not required
			return nil
		}

		if err := m.CancellationResponseType.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("CancellationResponseType")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("CancellationResponseType")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateChannelLocationBinding(ctx context.Context, formats strfmt.Registry) error {

	if m.ChannelLocationBinding != nil {

		if swag.IsZero(m.ChannelLocationBinding) { // not required
			return nil
		}

		if err := m.ChannelLocationBinding.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ChannelLocationBinding")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ChannelLocationBinding")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateChannelTag(ctx context.Context, formats strfmt.Registry) error {

	if m.ChannelTag != nil {

		if swag.IsZero(m.ChannelTag) { // not required
			return nil
		}

		if err := m.ChannelTag.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ChannelTag")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ChannelTag")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateConcurrencyKey(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ConcurrencyKey", "body", m.ConcurrencyKey); err != nil {
		return err
	}

	return nil
}

func (m *HeaderConfig) contextValidateConfigDiscount(ctx context.Context, formats strfmt.Registry) error {

	if m.ConfigDiscount != nil {

		if swag.IsZero(m.ConfigDiscount) { // not required
			return nil
		}

		if err := m.ConfigDiscount.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ConfigDiscount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ConfigDiscount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateDespatchNotes(ctx context.Context, formats strfmt.Registry) error {

	if m.DespatchNotes != nil {

		if swag.IsZero(m.DespatchNotes) { // not required
			return nil
		}

		if err := m.DespatchNotes.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("DespatchNotes")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("DespatchNotes")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateDisplayName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "DisplayName", "body", m.DisplayName); err != nil {
		return err
	}

	return nil
}

func (m *HeaderConfig) contextValidateDownloadRefunds(ctx context.Context, formats strfmt.Registry) error {

	if m.DownloadRefunds != nil {

		if swag.IsZero(m.DownloadRefunds) { // not required
			return nil
		}

		if err := m.DownloadRefunds.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("DownloadRefunds")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("DownloadRefunds")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateDownloadReturns(ctx context.Context, formats strfmt.Registry) error {

	if m.DownloadReturns != nil {

		if swag.IsZero(m.DownloadReturns) { // not required
			return nil
		}

		if err := m.DownloadReturns.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("DownloadReturns")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("DownloadReturns")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateDynamicProperties(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DynamicProperties); i++ {

		if m.DynamicProperties[i] != nil {

			if swag.IsZero(m.DynamicProperties[i]) { // not required
				return nil
			}

			if err := m.DynamicProperties[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("DynamicProperties" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("DynamicProperties" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *HeaderConfig) contextValidateEnabled(ctx context.Context, formats strfmt.Registry) error {

	if m.Enabled != nil {

		if swag.IsZero(m.Enabled) { // not required
			return nil
		}

		if err := m.Enabled.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("Enabled")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("Enabled")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateEndWhen(ctx context.Context, formats strfmt.Registry) error {

	if m.EndWhen != nil {

		if swag.IsZero(m.EndWhen) { // not required
			return nil
		}

		if err := m.EndWhen.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("EndWhen")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("EndWhen")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateEstimatedInventoryScanComplete(ctx context.Context, formats strfmt.Registry) error {

	if m.EstimatedInventoryScanComplete != nil {

		if swag.IsZero(m.EstimatedInventoryScanComplete) { // not required
			return nil
		}

		if err := m.EstimatedInventoryScanComplete.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("EstimatedInventoryScanComplete")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("EstimatedInventoryScanComplete")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateExtractInventory(ctx context.Context, formats strfmt.Registry) error {

	if m.ExtractInventory != nil {

		if swag.IsZero(m.ExtractInventory) { // not required
			return nil
		}

		if err := m.ExtractInventory.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ExtractInventory")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ExtractInventory")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateExtractInventoryVariationMappingPropertyName(ctx context.Context, formats strfmt.Registry) error {

	if m.ExtractInventoryVariationMappingPropertyName != nil {

		if swag.IsZero(m.ExtractInventoryVariationMappingPropertyName) { // not required
			return nil
		}

		if err := m.ExtractInventoryVariationMappingPropertyName.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ExtractInventoryVariationMappingPropertyName")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ExtractInventoryVariationMappingPropertyName")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateFulfillmentLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "FulfillmentLocation", "body", m.FulfillmentLocation); err != nil {
		return err
	}

	return nil
}

func (m *HeaderConfig) contextValidateFulfillmentServiceEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "FulfillmentServiceEnabled", "body", m.FulfillmentServiceEnabled); err != nil {
		return err
	}

	return nil
}

func (m *HeaderConfig) contextValidateHeaderAuditValues(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "HeaderAuditValues", "body", m.HeaderAuditValues); err != nil {
		return err
	}

	for i := 0; i < len(m.HeaderAuditValues); i++ {

		if m.HeaderAuditValues[i] != nil {

			if swag.IsZero(m.HeaderAuditValues[i]) { // not required
				return nil
			}

			if err := m.HeaderAuditValues[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("HeaderAuditValues" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("HeaderAuditValues" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *HeaderConfig) contextValidateHidesHeaderAttributes(ctx context.Context, formats strfmt.Registry) error {

	if m.HidesHeaderAttributes != nil {

		if swag.IsZero(m.HidesHeaderAttributes) { // not required
			return nil
		}

		if err := m.HidesHeaderAttributes.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("HidesHeaderAttributes")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("HidesHeaderAttributes")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateInvSyncErrorCount(ctx context.Context, formats strfmt.Registry) error {

	if m.InvSyncErrorCount != nil {

		if swag.IsZero(m.InvSyncErrorCount) { // not required
			return nil
		}

		if err := m.InvSyncErrorCount.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("InvSyncErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("InvSyncErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateInventorySync(ctx context.Context, formats strfmt.Registry) error {

	if m.InventorySync != nil {

		if swag.IsZero(m.InventorySync) { // not required
			return nil
		}

		if err := m.InventorySync.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("InventorySync")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("InventorySync")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateIsHeaderOnly(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsHeaderOnly", "body", m.IsHeaderOnly); err != nil {
		return err
	}

	return nil
}

func (m *HeaderConfig) contextValidateIsInventorySyncTriggerEnabled(ctx context.Context, formats strfmt.Registry) error {

	if m.IsInventorySyncTriggerEnabled != nil {

		if swag.IsZero(m.IsInventorySyncTriggerEnabled) { // not required
			return nil
		}

		if err := m.IsInventorySyncTriggerEnabled.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("IsInventorySyncTriggerEnabled")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("IsInventorySyncTriggerEnabled")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateIsListingScanRunning(ctx context.Context, formats strfmt.Registry) error {

	if m.IsListingScanRunning != nil {

		if swag.IsZero(m.IsListingScanRunning) { // not required
			return nil
		}

		if err := m.IsListingScanRunning.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("IsListingScanRunning")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("IsListingScanRunning")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateIsMultiLocation(ctx context.Context, formats strfmt.Registry) error {

	if m.IsMultiLocation != nil {

		if swag.IsZero(m.IsMultiLocation) { // not required
			return nil
		}

		if err := m.IsMultiLocation.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("IsMultiLocation")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("IsMultiLocation")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateIsOrdersSiteSpecific(ctx context.Context, formats strfmt.Registry) error {

	if m.IsOrdersSiteSpecific != nil {

		if swag.IsZero(m.IsOrdersSiteSpecific) { // not required
			return nil
		}

		if err := m.IsOrdersSiteSpecific.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("IsOrdersSiteSpecific")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("IsOrdersSiteSpecific")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateLastListingUpdateDate(ctx context.Context, formats strfmt.Registry) error {

	if m.LastListingUpdateDate != nil {

		if swag.IsZero(m.LastListingUpdateDate) { // not required
			return nil
		}

		if err := m.LastListingUpdateDate.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("LastListingUpdateDate")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("LastListingUpdateDate")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateListingScanStartUpdateDate(ctx context.Context, formats strfmt.Registry) error {

	if m.ListingScanStartUpdateDate != nil {

		if swag.IsZero(m.ListingScanStartUpdateDate) { // not required
			return nil
		}

		if err := m.ListingScanStartUpdateDate.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ListingScanStartUpdateDate")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ListingScanStartUpdateDate")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateMaxListed(ctx context.Context, formats strfmt.Registry) error {

	if m.MaxListed != nil {

		if swag.IsZero(m.MaxListed) { // not required
			return nil
		}

		if err := m.MaxListed.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("MaxListed")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("MaxListed")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateOrderCancellationCheckDate(ctx context.Context, formats strfmt.Registry) error {

	if m.OrderCancellationCheckDate != nil {

		if swag.IsZero(m.OrderCancellationCheckDate) { // not required
			return nil
		}

		if err := m.OrderCancellationCheckDate.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderCancellationCheckDate")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderCancellationCheckDate")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateOrderCancellationCheckErrorCount(ctx context.Context, formats strfmt.Registry) error {

	if m.OrderCancellationCheckErrorCount != nil {

		if swag.IsZero(m.OrderCancellationCheckErrorCount) { // not required
			return nil
		}

		if err := m.OrderCancellationCheckErrorCount.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderCancellationCheckErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderCancellationCheckErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateOrderCancellationCheckGlobalErrorCount(ctx context.Context, formats strfmt.Registry) error {

	if m.OrderCancellationCheckGlobalErrorCount != nil {

		if swag.IsZero(m.OrderCancellationCheckGlobalErrorCount) { // not required
			return nil
		}

		if err := m.OrderCancellationCheckGlobalErrorCount.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderCancellationCheckGlobalErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderCancellationCheckGlobalErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateOrderDespatchErrorCount(ctx context.Context, formats strfmt.Registry) error {

	if m.OrderDespatchErrorCount != nil {

		if swag.IsZero(m.OrderDespatchErrorCount) { // not required
			return nil
		}

		if err := m.OrderDespatchErrorCount.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderDespatchErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderDespatchErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateOrderDespatchGlobalErrorCount(ctx context.Context, formats strfmt.Registry) error {

	if m.OrderDespatchGlobalErrorCount != nil {

		if swag.IsZero(m.OrderDespatchGlobalErrorCount) { // not required
			return nil
		}

		if err := m.OrderDespatchGlobalErrorCount.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderDespatchGlobalErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderDespatchGlobalErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateOrderDownloadErrorCount(ctx context.Context, formats strfmt.Registry) error {

	if m.OrderDownloadErrorCount != nil {

		if swag.IsZero(m.OrderDownloadErrorCount) { // not required
			return nil
		}

		if err := m.OrderDownloadErrorCount.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderDownloadErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderDownloadErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateOrderDownloadGlobalErrorCount(ctx context.Context, formats strfmt.Registry) error {

	if m.OrderDownloadGlobalErrorCount != nil {

		if swag.IsZero(m.OrderDownloadGlobalErrorCount) { // not required
			return nil
		}

		if err := m.OrderDownloadGlobalErrorCount.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderDownloadGlobalErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderDownloadGlobalErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateOrderSaveLocation(ctx context.Context, formats strfmt.Registry) error {

	if m.OrderSaveLocation != nil {

		if swag.IsZero(m.OrderSaveLocation) { // not required
			return nil
		}

		if err := m.OrderSaveLocation.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderSaveLocation")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderSaveLocation")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateOrderSyncDate(ctx context.Context, formats strfmt.Registry) error {

	if m.OrderSyncDate != nil {

		if swag.IsZero(m.OrderSyncDate) { // not required
			return nil
		}

		if err := m.OrderSyncDate.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("OrderSyncDate")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("OrderSyncDate")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidatePaymentMethodMapping(ctx context.Context, formats strfmt.Registry) error {

	if m.PaymentMethodMapping != nil {

		if swag.IsZero(m.PaymentMethodMapping) { // not required
			return nil
		}

		if err := m.PaymentMethodMapping.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("PaymentMethodMapping")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("PaymentMethodMapping")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidatePostalServiceMapping(ctx context.Context, formats strfmt.Registry) error {

	if m.PostalServiceMapping != nil {

		if swag.IsZero(m.PostalServiceMapping) { // not required
			return nil
		}

		if err := m.PostalServiceMapping.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("PostalServiceMapping")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("PostalServiceMapping")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidatePriceChange(ctx context.Context, formats strfmt.Registry) error {

	if m.PriceChange != nil {

		if swag.IsZero(m.PriceChange) { // not required
			return nil
		}

		if err := m.PriceChange.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("PriceChange")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("PriceChange")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidatePriceChangeErrorCount(ctx context.Context, formats strfmt.Registry) error {

	if m.PriceChangeErrorCount != nil {

		if swag.IsZero(m.PriceChangeErrorCount) { // not required
			return nil
		}

		if err := m.PriceChangeErrorCount.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("PriceChangeErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("PriceChangeErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateProcessPosOrders(ctx context.Context, formats strfmt.Registry) error {

	if m.ProcessPosOrders != nil {

		if swag.IsZero(m.ProcessPosOrders) { // not required
			return nil
		}

		if err := m.ProcessPosOrders.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ProcessPosOrders")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ProcessPosOrders")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateRefundNotes(ctx context.Context, formats strfmt.Registry) error {

	if m.RefundNotes != nil {

		if swag.IsZero(m.RefundNotes) { // not required
			return nil
		}

		if err := m.RefundNotes.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("RefundNotes")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("RefundNotes")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateReturnNotes(ctx context.Context, formats strfmt.Registry) error {

	if m.ReturnNotes != nil {

		if swag.IsZero(m.ReturnNotes) { // not required
			return nil
		}

		if err := m.ReturnNotes.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ReturnNotes")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ReturnNotes")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateRmaDownloadErrorCount(ctx context.Context, formats strfmt.Registry) error {

	if m.RmaDownloadErrorCount != nil {

		if swag.IsZero(m.RmaDownloadErrorCount) { // not required
			return nil
		}

		if err := m.RmaDownloadErrorCount.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("RmaDownloadErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("RmaDownloadErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateRmaDownloadGlobalErrorCount(ctx context.Context, formats strfmt.Registry) error {

	if m.RmaDownloadGlobalErrorCount != nil {

		if swag.IsZero(m.RmaDownloadGlobalErrorCount) { // not required
			return nil
		}

		if err := m.RmaDownloadGlobalErrorCount.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("RmaDownloadGlobalErrorCount")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("RmaDownloadGlobalErrorCount")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateRules(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "Rules", "body", m.Rules); err != nil {
		return err
	}

	for i := 0; i < len(m.Rules); i++ {

		if m.Rules[i] != nil {

			if swag.IsZero(m.Rules[i]) { // not required
				return nil
			}

			if err := m.Rules[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Rules" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Rules" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *HeaderConfig) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "Source", "body", m.Source); err != nil {
		return err
	}

	return nil
}

func (m *HeaderConfig) contextValidateSourceType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "SourceType", "body", m.SourceType); err != nil {
		return err
	}

	return nil
}

func (m *HeaderConfig) contextValidateSourceVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.SourceVersion != nil {

		if swag.IsZero(m.SourceVersion) { // not required
			return nil
		}

		if err := m.SourceVersion.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("SourceVersion")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("SourceVersion")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateStockLocationBinding(ctx context.Context, formats strfmt.Registry) error {

	if m.StockLocationBinding != nil {

		if swag.IsZero(m.StockLocationBinding) { // not required
			return nil
		}

		if err := m.StockLocationBinding.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("StockLocationBinding")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("StockLocationBinding")
			}

			return err
		}
	}

	return nil
}

func (m *HeaderConfig) contextValidateStockPercentage(ctx context.Context, formats strfmt.Registry) error {

	if m.StockPercentage != nil {

		if swag.IsZero(m.StockPercentage) { // not required
			return nil
		}

		if err := m.StockPercentage.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("StockPercentage")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("StockPercentage")
			}

			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *HeaderConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HeaderConfig) UnmarshalBinary(b []byte) error {
	var res HeaderConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
