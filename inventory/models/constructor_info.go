// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	stderrors "errors"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ConstructorInfo constructor info
//
// swagger:model ConstructorInfo
type ConstructorInfo struct {

	// attributes
	// Read Only: true
	// Enum: ["MemberAccessMask","PrivateScope","Private","FamANDAssem","Assembly","Family","FamORAssem","Public","Static","Final","Virtual","HideBySig","CheckAccessOnOverride","VtableLayoutMask","ReuseSlot","NewSlot","Abstract","SpecialName","PinvokeImpl","UnmanagedExport","RTSpecialName","ReservedMask","HasSecurity","RequireSecObject"]
	Attributes string `json:"Attributes,omitempty"`

	// calling convention
	// Read Only: true
	// Enum: ["Standard","VarArgs","Any","HasThis","ExplicitThis"]
	CallingConvention string `json:"CallingConvention,omitempty"`

	// contains generic parameters
	// Read Only: true
	ContainsGenericParameters *bool `json:"ContainsGenericParameters,omitempty"`

	// custom attributes
	// Read Only: true
	CustomAttributes []*CustomAttributeData `json:"CustomAttributes"`

	// declaring type
	// Read Only: true
	DeclaringType string `json:"DeclaringType,omitempty"`

	// is abstract
	// Read Only: true
	IsAbstract *bool `json:"IsAbstract,omitempty"`

	// is assembly
	// Read Only: true
	IsAssembly *bool `json:"IsAssembly,omitempty"`

	// is constructor
	// Read Only: true
	IsConstructor *bool `json:"IsConstructor,omitempty"`

	// is family
	// Read Only: true
	IsFamily *bool `json:"IsFamily,omitempty"`

	// is family and assembly
	// Read Only: true
	IsFamilyAndAssembly *bool `json:"IsFamilyAndAssembly,omitempty"`

	// is family or assembly
	// Read Only: true
	IsFamilyOrAssembly *bool `json:"IsFamilyOrAssembly,omitempty"`

	// is final
	// Read Only: true
	IsFinal *bool `json:"IsFinal,omitempty"`

	// is generic method
	// Read Only: true
	IsGenericMethod *bool `json:"IsGenericMethod,omitempty"`

	// is generic method definition
	// Read Only: true
	IsGenericMethodDefinition *bool `json:"IsGenericMethodDefinition,omitempty"`

	// is hide by sig
	// Read Only: true
	IsHideBySig *bool `json:"IsHideBySig,omitempty"`

	// is private
	// Read Only: true
	IsPrivate *bool `json:"IsPrivate,omitempty"`

	// is public
	// Read Only: true
	IsPublic *bool `json:"IsPublic,omitempty"`

	// is security critical
	// Read Only: true
	IsSecurityCritical *bool `json:"IsSecurityCritical,omitempty"`

	// is security safe critical
	// Read Only: true
	IsSecuritySafeCritical *bool `json:"IsSecuritySafeCritical,omitempty"`

	// is security transparent
	// Read Only: true
	IsSecurityTransparent *bool `json:"IsSecurityTransparent,omitempty"`

	// is special name
	// Read Only: true
	IsSpecialName *bool `json:"IsSpecialName,omitempty"`

	// is static
	// Read Only: true
	IsStatic *bool `json:"IsStatic,omitempty"`

	// is virtual
	// Read Only: true
	IsVirtual *bool `json:"IsVirtual,omitempty"`

	// member type
	// Read Only: true
	// Enum: ["Constructor","Event","Field","Method","Property","TypeInfo","Custom","NestedType","All"]
	MemberType string `json:"MemberType,omitempty"`

	// metadata token
	// Read Only: true
	MetadataToken int32 `json:"MetadataToken,omitempty"`

	// method handle
	// Read Only: true
	MethodHandle any `json:"MethodHandle,omitempty"`

	// method implementation flags
	// Read Only: true
	// Enum: ["CodeTypeMask","IL","Native","OPTIL","Runtime","ManagedMask","Unmanaged","Managed","ForwardRef","PreserveSig","InternalCall","Synchronized","NoInlining","AggressiveInlining","NoOptimization","SecurityMitigations","MaxMethodImplVal"]
	MethodImplementationFlags string `json:"MethodImplementationFlags,omitempty"`

	// module
	// Read Only: true
	Module any `json:"Module,omitempty"`

	// name
	// Read Only: true
	Name string `json:"Name,omitempty"`

	// reflected type
	// Read Only: true
	ReflectedType string `json:"ReflectedType,omitempty"`
}

// Validate validates this constructor info
func (m *ConstructorInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCallingConvention(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemberType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMethodImplementationFlags(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var constructorInfoTypeAttributesPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MemberAccessMask","PrivateScope","Private","FamANDAssem","Assembly","Family","FamORAssem","Public","Static","Final","Virtual","HideBySig","CheckAccessOnOverride","VtableLayoutMask","ReuseSlot","NewSlot","Abstract","SpecialName","PinvokeImpl","UnmanagedExport","RTSpecialName","ReservedMask","HasSecurity","RequireSecObject"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		constructorInfoTypeAttributesPropEnum = append(constructorInfoTypeAttributesPropEnum, v)
	}
}

const (

	// ConstructorInfoAttributesMemberAccessMask captures enum value "MemberAccessMask"
	ConstructorInfoAttributesMemberAccessMask string = "MemberAccessMask"

	// ConstructorInfoAttributesPrivateScope captures enum value "PrivateScope"
	ConstructorInfoAttributesPrivateScope string = "PrivateScope"

	// ConstructorInfoAttributesPrivate captures enum value "Private"
	ConstructorInfoAttributesPrivate string = "Private"

	// ConstructorInfoAttributesFamANDAssem captures enum value "FamANDAssem"
	ConstructorInfoAttributesFamANDAssem string = "FamANDAssem"

	// ConstructorInfoAttributesAssembly captures enum value "Assembly"
	ConstructorInfoAttributesAssembly string = "Assembly"

	// ConstructorInfoAttributesFamily captures enum value "Family"
	ConstructorInfoAttributesFamily string = "Family"

	// ConstructorInfoAttributesFamORAssem captures enum value "FamORAssem"
	ConstructorInfoAttributesFamORAssem string = "FamORAssem"

	// ConstructorInfoAttributesPublic captures enum value "Public"
	ConstructorInfoAttributesPublic string = "Public"

	// ConstructorInfoAttributesStatic captures enum value "Static"
	ConstructorInfoAttributesStatic string = "Static"

	// ConstructorInfoAttributesFinal captures enum value "Final"
	ConstructorInfoAttributesFinal string = "Final"

	// ConstructorInfoAttributesVirtual captures enum value "Virtual"
	ConstructorInfoAttributesVirtual string = "Virtual"

	// ConstructorInfoAttributesHideBySig captures enum value "HideBySig"
	ConstructorInfoAttributesHideBySig string = "HideBySig"

	// ConstructorInfoAttributesCheckAccessOnOverride captures enum value "CheckAccessOnOverride"
	ConstructorInfoAttributesCheckAccessOnOverride string = "CheckAccessOnOverride"

	// ConstructorInfoAttributesVtableLayoutMask captures enum value "VtableLayoutMask"
	ConstructorInfoAttributesVtableLayoutMask string = "VtableLayoutMask"

	// ConstructorInfoAttributesReuseSlot captures enum value "ReuseSlot"
	ConstructorInfoAttributesReuseSlot string = "ReuseSlot"

	// ConstructorInfoAttributesNewSlot captures enum value "NewSlot"
	ConstructorInfoAttributesNewSlot string = "NewSlot"

	// ConstructorInfoAttributesAbstract captures enum value "Abstract"
	ConstructorInfoAttributesAbstract string = "Abstract"

	// ConstructorInfoAttributesSpecialName captures enum value "SpecialName"
	ConstructorInfoAttributesSpecialName string = "SpecialName"

	// ConstructorInfoAttributesPinvokeImpl captures enum value "PinvokeImpl"
	ConstructorInfoAttributesPinvokeImpl string = "PinvokeImpl"

	// ConstructorInfoAttributesUnmanagedExport captures enum value "UnmanagedExport"
	ConstructorInfoAttributesUnmanagedExport string = "UnmanagedExport"

	// ConstructorInfoAttributesRTSpecialName captures enum value "RTSpecialName"
	ConstructorInfoAttributesRTSpecialName string = "RTSpecialName"

	// ConstructorInfoAttributesReservedMask captures enum value "ReservedMask"
	ConstructorInfoAttributesReservedMask string = "ReservedMask"

	// ConstructorInfoAttributesHasSecurity captures enum value "HasSecurity"
	ConstructorInfoAttributesHasSecurity string = "HasSecurity"

	// ConstructorInfoAttributesRequireSecObject captures enum value "RequireSecObject"
	ConstructorInfoAttributesRequireSecObject string = "RequireSecObject"
)

// prop value enum
func (m *ConstructorInfo) validateAttributesEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, constructorInfoTypeAttributesPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConstructorInfo) validateAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.Attributes) { // not required
		return nil
	}

	// value enum
	if err := m.validateAttributesEnum("Attributes", "body", m.Attributes); err != nil {
		return err
	}

	return nil
}

var constructorInfoTypeCallingConventionPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Standard","VarArgs","Any","HasThis","ExplicitThis"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		constructorInfoTypeCallingConventionPropEnum = append(constructorInfoTypeCallingConventionPropEnum, v)
	}
}

const (

	// ConstructorInfoCallingConventionStandard captures enum value "Standard"
	ConstructorInfoCallingConventionStandard string = "Standard"

	// ConstructorInfoCallingConventionVarArgs captures enum value "VarArgs"
	ConstructorInfoCallingConventionVarArgs string = "VarArgs"

	// ConstructorInfoCallingConventionAny captures enum value "Any"
	ConstructorInfoCallingConventionAny string = "Any"

	// ConstructorInfoCallingConventionHasThis captures enum value "HasThis"
	ConstructorInfoCallingConventionHasThis string = "HasThis"

	// ConstructorInfoCallingConventionExplicitThis captures enum value "ExplicitThis"
	ConstructorInfoCallingConventionExplicitThis string = "ExplicitThis"
)

// prop value enum
func (m *ConstructorInfo) validateCallingConventionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, constructorInfoTypeCallingConventionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConstructorInfo) validateCallingConvention(formats strfmt.Registry) error {
	if swag.IsZero(m.CallingConvention) { // not required
		return nil
	}

	// value enum
	if err := m.validateCallingConventionEnum("CallingConvention", "body", m.CallingConvention); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) validateCustomAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.CustomAttributes); i++ {
		if swag.IsZero(m.CustomAttributes[i]) { // not required
			continue
		}

		if m.CustomAttributes[i] != nil {
			if err := m.CustomAttributes[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("CustomAttributes" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("CustomAttributes" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

var constructorInfoTypeMemberTypePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Constructor","Event","Field","Method","Property","TypeInfo","Custom","NestedType","All"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		constructorInfoTypeMemberTypePropEnum = append(constructorInfoTypeMemberTypePropEnum, v)
	}
}

const (

	// ConstructorInfoMemberTypeConstructor captures enum value "Constructor"
	ConstructorInfoMemberTypeConstructor string = "Constructor"

	// ConstructorInfoMemberTypeEvent captures enum value "Event"
	ConstructorInfoMemberTypeEvent string = "Event"

	// ConstructorInfoMemberTypeField captures enum value "Field"
	ConstructorInfoMemberTypeField string = "Field"

	// ConstructorInfoMemberTypeMethod captures enum value "Method"
	ConstructorInfoMemberTypeMethod string = "Method"

	// ConstructorInfoMemberTypeProperty captures enum value "Property"
	ConstructorInfoMemberTypeProperty string = "Property"

	// ConstructorInfoMemberTypeTypeInfo captures enum value "TypeInfo"
	ConstructorInfoMemberTypeTypeInfo string = "TypeInfo"

	// ConstructorInfoMemberTypeCustom captures enum value "Custom"
	ConstructorInfoMemberTypeCustom string = "Custom"

	// ConstructorInfoMemberTypeNestedType captures enum value "NestedType"
	ConstructorInfoMemberTypeNestedType string = "NestedType"

	// ConstructorInfoMemberTypeAll captures enum value "All"
	ConstructorInfoMemberTypeAll string = "All"
)

// prop value enum
func (m *ConstructorInfo) validateMemberTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, constructorInfoTypeMemberTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConstructorInfo) validateMemberType(formats strfmt.Registry) error {
	if swag.IsZero(m.MemberType) { // not required
		return nil
	}

	// value enum
	if err := m.validateMemberTypeEnum("MemberType", "body", m.MemberType); err != nil {
		return err
	}

	return nil
}

var constructorInfoTypeMethodImplementationFlagsPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CodeTypeMask","IL","Native","OPTIL","Runtime","ManagedMask","Unmanaged","Managed","ForwardRef","PreserveSig","InternalCall","Synchronized","NoInlining","AggressiveInlining","NoOptimization","SecurityMitigations","MaxMethodImplVal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		constructorInfoTypeMethodImplementationFlagsPropEnum = append(constructorInfoTypeMethodImplementationFlagsPropEnum, v)
	}
}

const (

	// ConstructorInfoMethodImplementationFlagsCodeTypeMask captures enum value "CodeTypeMask"
	ConstructorInfoMethodImplementationFlagsCodeTypeMask string = "CodeTypeMask"

	// ConstructorInfoMethodImplementationFlagsIL captures enum value "IL"
	ConstructorInfoMethodImplementationFlagsIL string = "IL"

	// ConstructorInfoMethodImplementationFlagsNative captures enum value "Native"
	ConstructorInfoMethodImplementationFlagsNative string = "Native"

	// ConstructorInfoMethodImplementationFlagsOPTIL captures enum value "OPTIL"
	ConstructorInfoMethodImplementationFlagsOPTIL string = "OPTIL"

	// ConstructorInfoMethodImplementationFlagsRuntime captures enum value "Runtime"
	ConstructorInfoMethodImplementationFlagsRuntime string = "Runtime"

	// ConstructorInfoMethodImplementationFlagsManagedMask captures enum value "ManagedMask"
	ConstructorInfoMethodImplementationFlagsManagedMask string = "ManagedMask"

	// ConstructorInfoMethodImplementationFlagsUnmanaged captures enum value "Unmanaged"
	ConstructorInfoMethodImplementationFlagsUnmanaged string = "Unmanaged"

	// ConstructorInfoMethodImplementationFlagsManaged captures enum value "Managed"
	ConstructorInfoMethodImplementationFlagsManaged string = "Managed"

	// ConstructorInfoMethodImplementationFlagsForwardRef captures enum value "ForwardRef"
	ConstructorInfoMethodImplementationFlagsForwardRef string = "ForwardRef"

	// ConstructorInfoMethodImplementationFlagsPreserveSig captures enum value "PreserveSig"
	ConstructorInfoMethodImplementationFlagsPreserveSig string = "PreserveSig"

	// ConstructorInfoMethodImplementationFlagsInternalCall captures enum value "InternalCall"
	ConstructorInfoMethodImplementationFlagsInternalCall string = "InternalCall"

	// ConstructorInfoMethodImplementationFlagsSynchronized captures enum value "Synchronized"
	ConstructorInfoMethodImplementationFlagsSynchronized string = "Synchronized"

	// ConstructorInfoMethodImplementationFlagsNoInlining captures enum value "NoInlining"
	ConstructorInfoMethodImplementationFlagsNoInlining string = "NoInlining"

	// ConstructorInfoMethodImplementationFlagsAggressiveInlining captures enum value "AggressiveInlining"
	ConstructorInfoMethodImplementationFlagsAggressiveInlining string = "AggressiveInlining"

	// ConstructorInfoMethodImplementationFlagsNoOptimization captures enum value "NoOptimization"
	ConstructorInfoMethodImplementationFlagsNoOptimization string = "NoOptimization"

	// ConstructorInfoMethodImplementationFlagsSecurityMitigations captures enum value "SecurityMitigations"
	ConstructorInfoMethodImplementationFlagsSecurityMitigations string = "SecurityMitigations"

	// ConstructorInfoMethodImplementationFlagsMaxMethodImplVal captures enum value "MaxMethodImplVal"
	ConstructorInfoMethodImplementationFlagsMaxMethodImplVal string = "MaxMethodImplVal"
)

// prop value enum
func (m *ConstructorInfo) validateMethodImplementationFlagsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, constructorInfoTypeMethodImplementationFlagsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConstructorInfo) validateMethodImplementationFlags(formats strfmt.Registry) error {
	if swag.IsZero(m.MethodImplementationFlags) { // not required
		return nil
	}

	// value enum
	if err := m.validateMethodImplementationFlagsEnum("MethodImplementationFlags", "body", m.MethodImplementationFlags); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this constructor info based on the context it is used
func (m *ConstructorInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCallingConvention(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContainsGenericParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDeclaringType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsAbstract(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsAssembly(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsConstructor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsFamily(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsFamilyAndAssembly(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsFamilyOrAssembly(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsFinal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsGenericMethod(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsGenericMethodDefinition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsHideBySig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsPrivate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsPublic(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSecurityCritical(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSecuritySafeCritical(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSecurityTransparent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSpecialName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsStatic(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsVirtual(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMemberType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetadataToken(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMethodImplementationFlags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReflectedType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConstructorInfo) contextValidateAttributes(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "Attributes", "body", m.Attributes); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateCallingConvention(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "CallingConvention", "body", m.CallingConvention); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateContainsGenericParameters(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ContainsGenericParameters", "body", m.ContainsGenericParameters); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateCustomAttributes(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "CustomAttributes", "body", m.CustomAttributes); err != nil {
		return err
	}

	for i := 0; i < len(m.CustomAttributes); i++ {

		if m.CustomAttributes[i] != nil {

			if swag.IsZero(m.CustomAttributes[i]) { // not required
				return nil
			}

			if err := m.CustomAttributes[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("CustomAttributes" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("CustomAttributes" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *ConstructorInfo) contextValidateDeclaringType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "DeclaringType", "body", m.DeclaringType); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsAbstract(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsAbstract", "body", m.IsAbstract); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsAssembly(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsAssembly", "body", m.IsAssembly); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsConstructor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsConstructor", "body", m.IsConstructor); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsFamily(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsFamily", "body", m.IsFamily); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsFamilyAndAssembly(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsFamilyAndAssembly", "body", m.IsFamilyAndAssembly); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsFamilyOrAssembly(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsFamilyOrAssembly", "body", m.IsFamilyOrAssembly); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsFinal(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsFinal", "body", m.IsFinal); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsGenericMethod(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsGenericMethod", "body", m.IsGenericMethod); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsGenericMethodDefinition(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsGenericMethodDefinition", "body", m.IsGenericMethodDefinition); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsHideBySig(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsHideBySig", "body", m.IsHideBySig); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsPrivate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsPrivate", "body", m.IsPrivate); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsPublic(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsPublic", "body", m.IsPublic); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsSecurityCritical(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsSecurityCritical", "body", m.IsSecurityCritical); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsSecuritySafeCritical(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsSecuritySafeCritical", "body", m.IsSecuritySafeCritical); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsSecurityTransparent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsSecurityTransparent", "body", m.IsSecurityTransparent); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsSpecialName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsSpecialName", "body", m.IsSpecialName); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsStatic(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsStatic", "body", m.IsStatic); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateIsVirtual(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsVirtual", "body", m.IsVirtual); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateMemberType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "MemberType", "body", m.MemberType); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateMetadataToken(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "MetadataToken", "body", m.MetadataToken); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateMethodImplementationFlags(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "MethodImplementationFlags", "body", m.MethodImplementationFlags); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "Name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *ConstructorInfo) contextValidateReflectedType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ReflectedType", "body", m.ReflectedType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConstructorInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConstructorInfo) UnmarshalBinary(b []byte) error {
	var res ConstructorInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
