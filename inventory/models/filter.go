// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Filter filter
//
// swagger:model Filter
type Filter struct {

	// Condition type
	// Enum: ["Equals","Contains","Less","Greater","NotEquals","NotContains","Exists","Listed","NotListed","HasError","OnlyErrors","NoErrors","HasWarning","LastDays","OlderThan","Next","Is","InTheFeed","NotInTheFeed","Creating","Updating","Deleting"]
	Condition string `json:"Condition,omitempty"`

	// Condition display name
	// Read Only: true
	ConditionDisplayName string `json:"ConditionDisplayName,omitempty"`

	// Display name
	// Read Only: true
	DisplayName string `json:"DisplayName,omitempty"`

	// Type of filter field
	// Read Only: true
	// Enum: ["Int","Double","String","Boolean","Select","Date","Channel","Other","Datetime2","Calculated"]
	Field string `json:"Field,omitempty"`

	// Type of the filter
	// Enum: ["General","SKU","Title","RetailPrice","PurchasePrice","Tracked","Barcode","VariationGroupName","Available","MinimumLevel","InOrder","StockLevel","StockValue","Due","BinRack","Category","ChannelSKU","SupplierCode","eBayId","AmazonASIN","Image","ExtendedProperty","ExtendedPropertyName","Channel","CreatedDate","ModifiedDate","SerialNumberScanRequired","BatchNumberScanRequired","BatchType","BatchNumber","Weight","DimHeight","DimWidth","DimDepth","JIT","ReorderAmount","ReorderDate","AverageConsumption","DefaultSupplier","GeneralWithSeparatingWords"]
	FilterName string `json:"FilterName,omitempty"`

	// Filter name
	FilterNameExact []string `json:"FilterNameExact"`

	// Filter value
	Value string `json:"Value,omitempty"`
}

// Validate validates this filter
func (m *Filter) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCondition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateField(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilterName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var filterTypeConditionPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Equals","Contains","Less","Greater","NotEquals","NotContains","Exists","Listed","NotListed","HasError","OnlyErrors","NoErrors","HasWarning","LastDays","OlderThan","Next","Is","InTheFeed","NotInTheFeed","Creating","Updating","Deleting"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filterTypeConditionPropEnum = append(filterTypeConditionPropEnum, v)
	}
}

const (

	// FilterConditionEquals captures enum value "Equals"
	FilterConditionEquals string = "Equals"

	// FilterConditionContains captures enum value "Contains"
	FilterConditionContains string = "Contains"

	// FilterConditionLess captures enum value "Less"
	FilterConditionLess string = "Less"

	// FilterConditionGreater captures enum value "Greater"
	FilterConditionGreater string = "Greater"

	// FilterConditionNotEquals captures enum value "NotEquals"
	FilterConditionNotEquals string = "NotEquals"

	// FilterConditionNotContains captures enum value "NotContains"
	FilterConditionNotContains string = "NotContains"

	// FilterConditionExists captures enum value "Exists"
	FilterConditionExists string = "Exists"

	// FilterConditionListed captures enum value "Listed"
	FilterConditionListed string = "Listed"

	// FilterConditionNotListed captures enum value "NotListed"
	FilterConditionNotListed string = "NotListed"

	// FilterConditionHasError captures enum value "HasError"
	FilterConditionHasError string = "HasError"

	// FilterConditionOnlyErrors captures enum value "OnlyErrors"
	FilterConditionOnlyErrors string = "OnlyErrors"

	// FilterConditionNoErrors captures enum value "NoErrors"
	FilterConditionNoErrors string = "NoErrors"

	// FilterConditionHasWarning captures enum value "HasWarning"
	FilterConditionHasWarning string = "HasWarning"

	// FilterConditionLastDays captures enum value "LastDays"
	FilterConditionLastDays string = "LastDays"

	// FilterConditionOlderThan captures enum value "OlderThan"
	FilterConditionOlderThan string = "OlderThan"

	// FilterConditionNext captures enum value "Next"
	FilterConditionNext string = "Next"

	// FilterConditionIs captures enum value "Is"
	FilterConditionIs string = "Is"

	// FilterConditionInTheFeed captures enum value "InTheFeed"
	FilterConditionInTheFeed string = "InTheFeed"

	// FilterConditionNotInTheFeed captures enum value "NotInTheFeed"
	FilterConditionNotInTheFeed string = "NotInTheFeed"

	// FilterConditionCreating captures enum value "Creating"
	FilterConditionCreating string = "Creating"

	// FilterConditionUpdating captures enum value "Updating"
	FilterConditionUpdating string = "Updating"

	// FilterConditionDeleting captures enum value "Deleting"
	FilterConditionDeleting string = "Deleting"
)

// prop value enum
func (m *Filter) validateConditionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filterTypeConditionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Filter) validateCondition(formats strfmt.Registry) error {
	if swag.IsZero(m.Condition) { // not required
		return nil
	}

	// value enum
	if err := m.validateConditionEnum("Condition", "body", m.Condition); err != nil {
		return err
	}

	return nil
}

var filterTypeFieldPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Int","Double","String","Boolean","Select","Date","Channel","Other","Datetime2","Calculated"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filterTypeFieldPropEnum = append(filterTypeFieldPropEnum, v)
	}
}

const (

	// FilterFieldInt captures enum value "Int"
	FilterFieldInt string = "Int"

	// FilterFieldDouble captures enum value "Double"
	FilterFieldDouble string = "Double"

	// FilterFieldString captures enum value "String"
	FilterFieldString string = "String"

	// FilterFieldBoolean captures enum value "Boolean"
	FilterFieldBoolean string = "Boolean"

	// FilterFieldSelect captures enum value "Select"
	FilterFieldSelect string = "Select"

	// FilterFieldDate captures enum value "Date"
	FilterFieldDate string = "Date"

	// FilterFieldChannel captures enum value "Channel"
	FilterFieldChannel string = "Channel"

	// FilterFieldOther captures enum value "Other"
	FilterFieldOther string = "Other"

	// FilterFieldDatetime2 captures enum value "Datetime2"
	FilterFieldDatetime2 string = "Datetime2"

	// FilterFieldCalculated captures enum value "Calculated"
	FilterFieldCalculated string = "Calculated"
)

// prop value enum
func (m *Filter) validateFieldEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filterTypeFieldPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Filter) validateField(formats strfmt.Registry) error {
	if swag.IsZero(m.Field) { // not required
		return nil
	}

	// value enum
	if err := m.validateFieldEnum("Field", "body", m.Field); err != nil {
		return err
	}

	return nil
}

var filterTypeFilterNamePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["General","SKU","Title","RetailPrice","PurchasePrice","Tracked","Barcode","VariationGroupName","Available","MinimumLevel","InOrder","StockLevel","StockValue","Due","BinRack","Category","ChannelSKU","SupplierCode","eBayId","AmazonASIN","Image","ExtendedProperty","ExtendedPropertyName","Channel","CreatedDate","ModifiedDate","SerialNumberScanRequired","BatchNumberScanRequired","BatchType","BatchNumber","Weight","DimHeight","DimWidth","DimDepth","JIT","ReorderAmount","ReorderDate","AverageConsumption","DefaultSupplier","GeneralWithSeparatingWords"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filterTypeFilterNamePropEnum = append(filterTypeFilterNamePropEnum, v)
	}
}

const (

	// FilterFilterNameGeneral captures enum value "General"
	FilterFilterNameGeneral string = "General"

	// FilterFilterNameSKU captures enum value "SKU"
	FilterFilterNameSKU string = "SKU"

	// FilterFilterNameTitle captures enum value "Title"
	FilterFilterNameTitle string = "Title"

	// FilterFilterNameRetailPrice captures enum value "RetailPrice"
	FilterFilterNameRetailPrice string = "RetailPrice"

	// FilterFilterNamePurchasePrice captures enum value "PurchasePrice"
	FilterFilterNamePurchasePrice string = "PurchasePrice"

	// FilterFilterNameTracked captures enum value "Tracked"
	FilterFilterNameTracked string = "Tracked"

	// FilterFilterNameBarcode captures enum value "Barcode"
	FilterFilterNameBarcode string = "Barcode"

	// FilterFilterNameVariationGroupName captures enum value "VariationGroupName"
	FilterFilterNameVariationGroupName string = "VariationGroupName"

	// FilterFilterNameAvailable captures enum value "Available"
	FilterFilterNameAvailable string = "Available"

	// FilterFilterNameMinimumLevel captures enum value "MinimumLevel"
	FilterFilterNameMinimumLevel string = "MinimumLevel"

	// FilterFilterNameInOrder captures enum value "InOrder"
	FilterFilterNameInOrder string = "InOrder"

	// FilterFilterNameStockLevel captures enum value "StockLevel"
	FilterFilterNameStockLevel string = "StockLevel"

	// FilterFilterNameStockValue captures enum value "StockValue"
	FilterFilterNameStockValue string = "StockValue"

	// FilterFilterNameDue captures enum value "Due"
	FilterFilterNameDue string = "Due"

	// FilterFilterNameBinRack captures enum value "BinRack"
	FilterFilterNameBinRack string = "BinRack"

	// FilterFilterNameCategory captures enum value "Category"
	FilterFilterNameCategory string = "Category"

	// FilterFilterNameChannelSKU captures enum value "ChannelSKU"
	FilterFilterNameChannelSKU string = "ChannelSKU"

	// FilterFilterNameSupplierCode captures enum value "SupplierCode"
	FilterFilterNameSupplierCode string = "SupplierCode"

	// FilterFilterNameEBayID captures enum value "eBayId"
	FilterFilterNameEBayID string = "eBayId"

	// FilterFilterNameAmazonASIN captures enum value "AmazonASIN"
	FilterFilterNameAmazonASIN string = "AmazonASIN"

	// FilterFilterNameImage captures enum value "Image"
	FilterFilterNameImage string = "Image"

	// FilterFilterNameExtendedProperty captures enum value "ExtendedProperty"
	FilterFilterNameExtendedProperty string = "ExtendedProperty"

	// FilterFilterNameExtendedPropertyName captures enum value "ExtendedPropertyName"
	FilterFilterNameExtendedPropertyName string = "ExtendedPropertyName"

	// FilterFilterNameChannel captures enum value "Channel"
	FilterFilterNameChannel string = "Channel"

	// FilterFilterNameCreatedDate captures enum value "CreatedDate"
	FilterFilterNameCreatedDate string = "CreatedDate"

	// FilterFilterNameModifiedDate captures enum value "ModifiedDate"
	FilterFilterNameModifiedDate string = "ModifiedDate"

	// FilterFilterNameSerialNumberScanRequired captures enum value "SerialNumberScanRequired"
	FilterFilterNameSerialNumberScanRequired string = "SerialNumberScanRequired"

	// FilterFilterNameBatchNumberScanRequired captures enum value "BatchNumberScanRequired"
	FilterFilterNameBatchNumberScanRequired string = "BatchNumberScanRequired"

	// FilterFilterNameBatchType captures enum value "BatchType"
	FilterFilterNameBatchType string = "BatchType"

	// FilterFilterNameBatchNumber captures enum value "BatchNumber"
	FilterFilterNameBatchNumber string = "BatchNumber"

	// FilterFilterNameWeight captures enum value "Weight"
	FilterFilterNameWeight string = "Weight"

	// FilterFilterNameDimHeight captures enum value "DimHeight"
	FilterFilterNameDimHeight string = "DimHeight"

	// FilterFilterNameDimWidth captures enum value "DimWidth"
	FilterFilterNameDimWidth string = "DimWidth"

	// FilterFilterNameDimDepth captures enum value "DimDepth"
	FilterFilterNameDimDepth string = "DimDepth"

	// FilterFilterNameJIT captures enum value "JIT"
	FilterFilterNameJIT string = "JIT"

	// FilterFilterNameReorderAmount captures enum value "ReorderAmount"
	FilterFilterNameReorderAmount string = "ReorderAmount"

	// FilterFilterNameReorderDate captures enum value "ReorderDate"
	FilterFilterNameReorderDate string = "ReorderDate"

	// FilterFilterNameAverageConsumption captures enum value "AverageConsumption"
	FilterFilterNameAverageConsumption string = "AverageConsumption"

	// FilterFilterNameDefaultSupplier captures enum value "DefaultSupplier"
	FilterFilterNameDefaultSupplier string = "DefaultSupplier"

	// FilterFilterNameGeneralWithSeparatingWords captures enum value "GeneralWithSeparatingWords"
	FilterFilterNameGeneralWithSeparatingWords string = "GeneralWithSeparatingWords"
)

// prop value enum
func (m *Filter) validateFilterNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filterTypeFilterNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Filter) validateFilterName(formats strfmt.Registry) error {
	if swag.IsZero(m.FilterName) { // not required
		return nil
	}

	// value enum
	if err := m.validateFilterNameEnum("FilterName", "body", m.FilterName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this filter based on the context it is used
func (m *Filter) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateConditionDisplayName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDisplayName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateField(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Filter) contextValidateConditionDisplayName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ConditionDisplayName", "body", m.ConditionDisplayName); err != nil {
		return err
	}

	return nil
}

func (m *Filter) contextValidateDisplayName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "DisplayName", "body", m.DisplayName); err != nil {
		return err
	}

	return nil
}

func (m *Filter) contextValidateField(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "Field", "body", m.Field); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Filter) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Filter) UnmarshalBinary(b []byte) error {
	var res Filter
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
