// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	stderrors "errors"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InventoryView inventory view
//
// swagger:model InventoryView
type InventoryView struct {

	// View channels
	Channels []*InventoryChannel `json:"Channels"`

	// View columns
	Columns []*Column `json:"Columns"`

	// Country code
	CountryCode string `json:"CountryCode,omitempty"`

	// Country code
	CountryName string `json:"CountryName,omitempty"`

	// View filters
	Filters []*Filter `json:"Filters"`

	// View ID
	// Example: 00000000-0000-0000-0000-000000000000
	// Format: uuid
	ID strfmt.UUID `json:"Id,omitempty"`

	// Include archived products
	// Enum: ["All","Archived","NotArchived"]
	IncludeProducts string `json:"IncludeProducts,omitempty"`

	// What listing types to show
	// Enum: ["All","Variations","NonVariations","SingleItems"]
	Listing string `json:"Listing,omitempty"`

	// Show listed or not listed
	// Enum: ["All","Listed","NotListed","Errors"]
	Mode string `json:"Mode,omitempty"`

	// View name
	Name string `json:"Name,omitempty"`

	// Show only changed items
	ShowOnlyChanged bool `json:"ShowOnlyChanged,omitempty"`

	// ChannelName/Source (e.g. EBAY)
	Source string `json:"Source,omitempty"`

	// SubSource (e.g. EBAY1)
	SubSource string `json:"SubSource,omitempty"`
}

// Validate validates this inventory view
func (m *InventoryView) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateChannels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateColumns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIncludeProducts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateListing(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InventoryView) validateChannels(formats strfmt.Registry) error {
	if swag.IsZero(m.Channels) { // not required
		return nil
	}

	for i := 0; i < len(m.Channels); i++ {
		if swag.IsZero(m.Channels[i]) { // not required
			continue
		}

		if m.Channels[i] != nil {
			if err := m.Channels[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Channels" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Channels" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *InventoryView) validateColumns(formats strfmt.Registry) error {
	if swag.IsZero(m.Columns) { // not required
		return nil
	}

	for i := 0; i < len(m.Columns); i++ {
		if swag.IsZero(m.Columns[i]) { // not required
			continue
		}

		if m.Columns[i] != nil {
			if err := m.Columns[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Columns" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Columns" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *InventoryView) validateFilters(formats strfmt.Registry) error {
	if swag.IsZero(m.Filters) { // not required
		return nil
	}

	for i := 0; i < len(m.Filters); i++ {
		if swag.IsZero(m.Filters[i]) { // not required
			continue
		}

		if m.Filters[i] != nil {
			if err := m.Filters[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Filters" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Filters" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *InventoryView) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.FormatOf("Id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

var inventoryViewTypeIncludeProductsPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["All","Archived","NotArchived"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		inventoryViewTypeIncludeProductsPropEnum = append(inventoryViewTypeIncludeProductsPropEnum, v)
	}
}

const (

	// InventoryViewIncludeProductsAll captures enum value "All"
	InventoryViewIncludeProductsAll string = "All"

	// InventoryViewIncludeProductsArchived captures enum value "Archived"
	InventoryViewIncludeProductsArchived string = "Archived"

	// InventoryViewIncludeProductsNotArchived captures enum value "NotArchived"
	InventoryViewIncludeProductsNotArchived string = "NotArchived"
)

// prop value enum
func (m *InventoryView) validateIncludeProductsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, inventoryViewTypeIncludeProductsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InventoryView) validateIncludeProducts(formats strfmt.Registry) error {
	if swag.IsZero(m.IncludeProducts) { // not required
		return nil
	}

	// value enum
	if err := m.validateIncludeProductsEnum("IncludeProducts", "body", m.IncludeProducts); err != nil {
		return err
	}

	return nil
}

var inventoryViewTypeListingPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["All","Variations","NonVariations","SingleItems"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		inventoryViewTypeListingPropEnum = append(inventoryViewTypeListingPropEnum, v)
	}
}

const (

	// InventoryViewListingAll captures enum value "All"
	InventoryViewListingAll string = "All"

	// InventoryViewListingVariations captures enum value "Variations"
	InventoryViewListingVariations string = "Variations"

	// InventoryViewListingNonVariations captures enum value "NonVariations"
	InventoryViewListingNonVariations string = "NonVariations"

	// InventoryViewListingSingleItems captures enum value "SingleItems"
	InventoryViewListingSingleItems string = "SingleItems"
)

// prop value enum
func (m *InventoryView) validateListingEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, inventoryViewTypeListingPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InventoryView) validateListing(formats strfmt.Registry) error {
	if swag.IsZero(m.Listing) { // not required
		return nil
	}

	// value enum
	if err := m.validateListingEnum("Listing", "body", m.Listing); err != nil {
		return err
	}

	return nil
}

var inventoryViewTypeModePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["All","Listed","NotListed","Errors"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		inventoryViewTypeModePropEnum = append(inventoryViewTypeModePropEnum, v)
	}
}

const (

	// InventoryViewModeAll captures enum value "All"
	InventoryViewModeAll string = "All"

	// InventoryViewModeListed captures enum value "Listed"
	InventoryViewModeListed string = "Listed"

	// InventoryViewModeNotListed captures enum value "NotListed"
	InventoryViewModeNotListed string = "NotListed"

	// InventoryViewModeErrors captures enum value "Errors"
	InventoryViewModeErrors string = "Errors"
)

// prop value enum
func (m *InventoryView) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, inventoryViewTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InventoryView) validateMode(formats strfmt.Registry) error {
	if swag.IsZero(m.Mode) { // not required
		return nil
	}

	// value enum
	if err := m.validateModeEnum("Mode", "body", m.Mode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this inventory view based on the context it is used
func (m *InventoryView) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateChannels(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateColumns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InventoryView) contextValidateChannels(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Channels); i++ {

		if m.Channels[i] != nil {

			if swag.IsZero(m.Channels[i]) { // not required
				return nil
			}

			if err := m.Channels[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Channels" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Channels" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *InventoryView) contextValidateColumns(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Columns); i++ {

		if m.Columns[i] != nil {

			if swag.IsZero(m.Columns[i]) { // not required
				return nil
			}

			if err := m.Columns[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Columns" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Columns" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *InventoryView) contextValidateFilters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Filters); i++ {

		if m.Filters[i] != nil {

			if swag.IsZero(m.Filters[i]) { // not required
				return nil
			}

			if err := m.Filters[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Filters" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Filters" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *InventoryView) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InventoryView) UnmarshalBinary(b []byte) error {
	var res InventoryView
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
