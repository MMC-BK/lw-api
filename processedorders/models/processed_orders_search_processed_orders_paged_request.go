// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProcessedOrdersSearchProcessedOrdersPagedRequest processed orders search processed orders paged request
//
// swagger:model ProcessedOrders_SearchProcessedOrdersPagedRequest
type ProcessedOrdersSearchProcessedOrdersPagedRequest struct {

	// The search type (e.g. ALLDATES)
	// Enum: ["ALLDATES","RECEIVED","PROCESSED","PAYMENTRECEIVED","CANCELLED"]
	DateType string `json:"dateType,omitempty"`

	// Set to true if an exact match is required for the search data.
	ExactMatch bool `json:"exactMatch,omitempty"`

	// The lower end of the date range to search. Can be null if searching for 'all dates'. Maximum range is 3 months.
	// Format: date-time
	From strfmt.DateTime `json:"from,omitempty"`

	// The number of entries required on a page. Maximum 200.
	NumEntriesPerPage int32 `json:"numEntriesPerPage,omitempty"`

	// The page number of the request.
	PageNum int32 `json:"pageNum,omitempty"`

	// The field to search by. Can be found by calling GetSearchTypes.
	SearchField string `json:"searchField,omitempty"`

	// The term which you are searching for.
	SearchTerm string `json:"searchTerm,omitempty"`

	// The upper end of the date range to search. Can be null if searching for 'all dates'. Maximum range is 3 months.
	// Format: date-time
	To strfmt.DateTime `json:"to,omitempty"`
}

// Validate validates this processed orders search processed orders paged request
func (m *ProcessedOrdersSearchProcessedOrdersPagedRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var processedOrdersSearchProcessedOrdersPagedRequestTypeDateTypePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ALLDATES","RECEIVED","PROCESSED","PAYMENTRECEIVED","CANCELLED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		processedOrdersSearchProcessedOrdersPagedRequestTypeDateTypePropEnum = append(processedOrdersSearchProcessedOrdersPagedRequestTypeDateTypePropEnum, v)
	}
}

const (

	// ProcessedOrdersSearchProcessedOrdersPagedRequestDateTypeALLDATES captures enum value "ALLDATES"
	ProcessedOrdersSearchProcessedOrdersPagedRequestDateTypeALLDATES string = "ALLDATES"

	// ProcessedOrdersSearchProcessedOrdersPagedRequestDateTypeRECEIVED captures enum value "RECEIVED"
	ProcessedOrdersSearchProcessedOrdersPagedRequestDateTypeRECEIVED string = "RECEIVED"

	// ProcessedOrdersSearchProcessedOrdersPagedRequestDateTypePROCESSED captures enum value "PROCESSED"
	ProcessedOrdersSearchProcessedOrdersPagedRequestDateTypePROCESSED string = "PROCESSED"

	// ProcessedOrdersSearchProcessedOrdersPagedRequestDateTypePAYMENTRECEIVED captures enum value "PAYMENTRECEIVED"
	ProcessedOrdersSearchProcessedOrdersPagedRequestDateTypePAYMENTRECEIVED string = "PAYMENTRECEIVED"

	// ProcessedOrdersSearchProcessedOrdersPagedRequestDateTypeCANCELLED captures enum value "CANCELLED"
	ProcessedOrdersSearchProcessedOrdersPagedRequestDateTypeCANCELLED string = "CANCELLED"
)

// prop value enum
func (m *ProcessedOrdersSearchProcessedOrdersPagedRequest) validateDateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, processedOrdersSearchProcessedOrdersPagedRequestTypeDateTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProcessedOrdersSearchProcessedOrdersPagedRequest) validateDateType(formats strfmt.Registry) error {
	if swag.IsZero(m.DateType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDateTypeEnum("dateType", "body", m.DateType); err != nil {
		return err
	}

	return nil
}

func (m *ProcessedOrdersSearchProcessedOrdersPagedRequest) validateFrom(formats strfmt.Registry) error {
	if swag.IsZero(m.From) { // not required
		return nil
	}

	if err := validate.FormatOf("from", "body", "date-time", m.From.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ProcessedOrdersSearchProcessedOrdersPagedRequest) validateTo(formats strfmt.Registry) error {
	if swag.IsZero(m.To) { // not required
		return nil
	}

	if err := validate.FormatOf("to", "body", "date-time", m.To.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this processed orders search processed orders paged request based on context it is used
func (m *ProcessedOrdersSearchProcessedOrdersPagedRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ProcessedOrdersSearchProcessedOrdersPagedRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProcessedOrdersSearchProcessedOrdersPagedRequest) UnmarshalBinary(b []byte) error {
	var res ProcessedOrdersSearchProcessedOrdersPagedRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
