// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	stderrors "errors"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CalcOrderHeader Class represents a single instance of an order and its header packaging information. Note that if the order contains split packaging fkPackagingTypeId will be Empty Guid
//
// swagger:model CalcOrderHeader
type CalcOrderHeader struct {

	// List of bins (split packaging)
	Bins []*CalcBin `json:"Bins"`

	// Calculation comments. The recalculation routine will output some basic comments about how the calculation was performed in English.
	CalculationHints []string `json:"CalculationHints"`

	// can auto split
	// Read Only: true
	CanAutoSplit *bool `json:"CanAutoSplit,omitempty"`

	// Dimension Calculation method
	// Enum: ["LEGACY","MAX","STACKED","WEIGHTFIT","THREEDIM_ALL","THREEDIM_ITEMS"]
	DimMethod string `json:"DimMethod,omitempty"`

	// Was the packaging automatically split? Usually by the 3D Packaging method.
	IsAutoSplit bool `json:"IsAutoSplit,omitempty"`

	// Is the packaging split?
	// Read Only: true
	IsSplitPackaging *bool `json:"IsSplitPackaging,omitempty"`

	// Total Item weight in the order
	ItemWeight float64 `json:"ItemWeight,omitempty"`

	// List of order items (excluding composite parents)
	Items []*CalcOrderItem `json:"Items"`

	// Is Label Printed
	LabelPrinted bool `json:"LabelPrinted,omitempty"`

	// Inidicates that order weights, packaging dimensions has been manually adjusted by the user and therefore automatic recalculation should not be performed for this order
	ManualAdjust bool `json:"ManualAdjust,omitempty"`

	// Packaging weight
	PackagingWeight float64 `json:"PackagingWeight,omitempty"`

	// Indicates the number of split packaging bins. If null, or 0 - no split packaging
	SplitPackageCount int32 `json:"SplitPackageCount,omitempty"`

	// Result for volumetric packaging
	ThreeDimPackaging *PackingResult `json:"ThreeDimPackaging,omitempty"`

	// Total Depth of the order packaging. If null the recalculation was not performed yet. See documentation about how the dimensions of the order calculated.
	TotalDepth float64 `json:"TotalDepth,omitempty"`

	// Total Height of the order packaging. If null the recalculation was not performed yet. See documentation about how the dimensions of the order calculated.
	TotalHeight float64 `json:"TotalHeight,omitempty"`

	// Total weight, items + packaging weight
	TotalWeight float64 `json:"TotalWeight,omitempty"`

	// Total width of the order packaging. If null the recalculation was not performed yet. See documentation about how the dimensions of the order calculated.
	TotalWidth float64 `json:"TotalWidth,omitempty"`

	// Country Name
	CCountry string `json:"cCountry,omitempty"`

	// Country Id
	// Example: 00000000-0000-0000-0000-000000000000
	// Format: uuid
	FkCountryID strfmt.UUID `json:"fkCountryId,omitempty"`

	// Packaging Group Id
	// Example: 00000000-0000-0000-0000-000000000000
	// Format: uuid
	FkPackagingGroupID strfmt.UUID `json:"fkPackagingGroupId,omitempty"`

	// Calculated packaging type for the order
	// Example: 00000000-0000-0000-0000-000000000000
	// Format: uuid
	FkPackagingTypeID strfmt.UUID `json:"fkPackagingTypeId,omitempty"`

	// Shipping service id
	// Example: 00000000-0000-0000-0000-000000000000
	// Format: uuid
	FkPostalServiceID strfmt.UUID `json:"fkPostalServiceId,omitempty"`

	// Numeric order id
	NOrderID int32 `json:"nOrderId,omitempty"`

	// Order id
	// Example: 00000000-0000-0000-0000-000000000000
	// Format: uuid
	PkOrderID strfmt.UUID `json:"pkOrderID,omitempty"`
}

// Validate validates this calc order header
func (m *CalcOrderHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDimMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThreeDimPackaging(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFkCountryID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFkPackagingGroupID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFkPackagingTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFkPostalServiceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePkOrderID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CalcOrderHeader) validateBins(formats strfmt.Registry) error {
	if swag.IsZero(m.Bins) { // not required
		return nil
	}

	for i := 0; i < len(m.Bins); i++ {
		if swag.IsZero(m.Bins[i]) { // not required
			continue
		}

		if m.Bins[i] != nil {
			if err := m.Bins[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Bins" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Bins" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

var calcOrderHeaderTypeDimMethodPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LEGACY","MAX","STACKED","WEIGHTFIT","THREEDIM_ALL","THREEDIM_ITEMS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		calcOrderHeaderTypeDimMethodPropEnum = append(calcOrderHeaderTypeDimMethodPropEnum, v)
	}
}

const (

	// CalcOrderHeaderDimMethodLEGACY captures enum value "LEGACY"
	CalcOrderHeaderDimMethodLEGACY string = "LEGACY"

	// CalcOrderHeaderDimMethodMAX captures enum value "MAX"
	CalcOrderHeaderDimMethodMAX string = "MAX"

	// CalcOrderHeaderDimMethodSTACKED captures enum value "STACKED"
	CalcOrderHeaderDimMethodSTACKED string = "STACKED"

	// CalcOrderHeaderDimMethodWEIGHTFIT captures enum value "WEIGHTFIT"
	CalcOrderHeaderDimMethodWEIGHTFIT string = "WEIGHTFIT"

	// CalcOrderHeaderDimMethodTHREEDIMALL captures enum value "THREEDIM_ALL"
	CalcOrderHeaderDimMethodTHREEDIMALL string = "THREEDIM_ALL"

	// CalcOrderHeaderDimMethodTHREEDIMITEMS captures enum value "THREEDIM_ITEMS"
	CalcOrderHeaderDimMethodTHREEDIMITEMS string = "THREEDIM_ITEMS"
)

// prop value enum
func (m *CalcOrderHeader) validateDimMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, calcOrderHeaderTypeDimMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CalcOrderHeader) validateDimMethod(formats strfmt.Registry) error {
	if swag.IsZero(m.DimMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateDimMethodEnum("DimMethod", "body", m.DimMethod); err != nil {
		return err
	}

	return nil
}

func (m *CalcOrderHeader) validateItems(formats strfmt.Registry) error {
	if swag.IsZero(m.Items) { // not required
		return nil
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Items" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Items" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *CalcOrderHeader) validateThreeDimPackaging(formats strfmt.Registry) error {
	if swag.IsZero(m.ThreeDimPackaging) { // not required
		return nil
	}

	if m.ThreeDimPackaging != nil {
		if err := m.ThreeDimPackaging.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ThreeDimPackaging")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ThreeDimPackaging")
			}

			return err
		}
	}

	return nil
}

func (m *CalcOrderHeader) validateFkCountryID(formats strfmt.Registry) error {
	if swag.IsZero(m.FkCountryID) { // not required
		return nil
	}

	if err := validate.FormatOf("fkCountryId", "body", "uuid", m.FkCountryID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CalcOrderHeader) validateFkPackagingGroupID(formats strfmt.Registry) error {
	if swag.IsZero(m.FkPackagingGroupID) { // not required
		return nil
	}

	if err := validate.FormatOf("fkPackagingGroupId", "body", "uuid", m.FkPackagingGroupID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CalcOrderHeader) validateFkPackagingTypeID(formats strfmt.Registry) error {
	if swag.IsZero(m.FkPackagingTypeID) { // not required
		return nil
	}

	if err := validate.FormatOf("fkPackagingTypeId", "body", "uuid", m.FkPackagingTypeID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CalcOrderHeader) validateFkPostalServiceID(formats strfmt.Registry) error {
	if swag.IsZero(m.FkPostalServiceID) { // not required
		return nil
	}

	if err := validate.FormatOf("fkPostalServiceId", "body", "uuid", m.FkPostalServiceID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CalcOrderHeader) validatePkOrderID(formats strfmt.Registry) error {
	if swag.IsZero(m.PkOrderID) { // not required
		return nil
	}

	if err := validate.FormatOf("pkOrderID", "body", "uuid", m.PkOrderID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this calc order header based on the context it is used
func (m *CalcOrderHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBins(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCanAutoSplit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSplitPackaging(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThreeDimPackaging(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CalcOrderHeader) contextValidateBins(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Bins); i++ {

		if m.Bins[i] != nil {

			if swag.IsZero(m.Bins[i]) { // not required
				return nil
			}

			if err := m.Bins[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Bins" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Bins" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *CalcOrderHeader) contextValidateCanAutoSplit(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "CanAutoSplit", "body", m.CanAutoSplit); err != nil {
		return err
	}

	return nil
}

func (m *CalcOrderHeader) contextValidateIsSplitPackaging(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "IsSplitPackaging", "body", m.IsSplitPackaging); err != nil {
		return err
	}

	return nil
}

func (m *CalcOrderHeader) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {

			if swag.IsZero(m.Items[i]) { // not required
				return nil
			}

			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Items" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Items" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *CalcOrderHeader) contextValidateThreeDimPackaging(ctx context.Context, formats strfmt.Registry) error {

	if m.ThreeDimPackaging != nil {

		if swag.IsZero(m.ThreeDimPackaging) { // not required
			return nil
		}

		if err := m.ThreeDimPackaging.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("ThreeDimPackaging")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("ThreeDimPackaging")
			}

			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CalcOrderHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CalcOrderHeader) UnmarshalBinary(b []byte) error {
	var res CalcOrderHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
