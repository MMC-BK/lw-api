// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	stderrors "errors"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ChannelOrder channel order
//
// swagger:model ChannelOrder
type ChannelOrder struct {

	// When the order is saved it will try and link by ASIN after trying by channel sku mapping.
	AutomaticallyLinkByASIN bool `json:"AutomaticallyLinkByASIN,omitempty"`

	// When the order is saved it will try and link by Barcode after trying by channel sku mapping.
	AutomaticallyLinkByBarcode bool `json:"AutomaticallyLinkByBarcode,omitempty"`

	// When the order is saved it will try and link by SKU after trying by channel sku mapping.
	AutomaticallyLinkBySKU bool `json:"AutomaticallyLinkBySKU,omitempty"`

	// The orders billing address
	BillingAddress *ChannelAddress `json:"BillingAddress,omitempty"`

	// The tax number of the buyer
	BuyerTaxNumber string `json:"BuyerTaxNumber,omitempty"`

	// Channel buyer username / name
	ChannelBuyerName string `json:"ChannelBuyerName,omitempty"`

	// The currency conversion rate Sale/Base
	ConversionRate float64 `json:"ConversionRate,omitempty"`

	// Currency of the order, if value is null, empty or white space it will default to UNK
	Currency string `json:"Currency,omitempty"`

	// The order delivery address
	DeliveryAddress *ChannelAddress `json:"DeliveryAddress,omitempty"`

	// Channel specified delivery end date (do not set where is not provided)
	// Format: date-time
	DeliveryEndDate strfmt.DateTime `json:"DeliveryEndDate,omitempty"`

	// Channel specified delivery start date (do not set where is not provided)
	// Format: date-time
	DeliveryStartDate strfmt.DateTime `json:"DeliveryStartDate,omitempty"`

	// This represents the final discount applied to the order, as a value (not a percentage), after all item-level discounts are applied. It will be split evenly across all order items
	Discount float64 `json:"Discount,omitempty"`

	// This represents if the discount is applied before or after tax
	// Enum: ["DeductAfterTax","DeductBeforeTax"]
	DiscountTaxType string `json:"DiscountTaxType,omitempty"`

	// This represents how the discount will be split between items and postage. For an expsanation of each opiton, see the enum documentation
	// Enum: ["AllEvenly","ItemsThenPostage","PostageThenItems"]
	DiscountType string `json:"DiscountType,omitempty"`

	// UTC date/time the order should be despatched by
	// Format: date-time
	DispatchBy strfmt.DateTime `json:"DispatchBy,omitempty"`

	// List of extended properties for the order
	ExtendedProperties []*ChannelOrderExtendedProperty `json:"ExtendedProperties"`

	// External Reference
	ExternalReference string `json:"ExternalReference,omitempty"`

	// Bool to re-save order
	ForceReSaveFulfilledOrder bool `json:"ForceReSaveFulfilledOrder,omitempty"`

	// The refund amount applied across all items
	ItemsRefund float64 `json:"ItemsRefund,omitempty"`

	// The known refund allocation for the order lines
	// Enum: ["Unknown","OrderLevel","LineLevel","Both"]
	LineRefundAllocation string `json:"LineRefundAllocation,omitempty"`

	// The order location(s) on the channel
	Locations []*ChannelOrderLocation `json:"Locations"`

	// Overrides the mapping source for the channel for example if the Source is 'AMAZON FBA' MappingSource can be used to override to 'AMAZON'
	MappingSource string `json:"MappingSource,omitempty"`

	// Match payment method by name
	MatchPaymentMethodTag string `json:"MatchPaymentMethodTag,omitempty"`

	// Match postal service method by name
	MatchPostalServiceTag string `json:"MatchPostalServiceTag,omitempty"`

	// List of notes for the order
	Notes []*ChannelOrderNote `json:"Notes"`

	// Defines type of fulfilment required for order
	// Enum: ["Manual","POS","DigitalOnly","FulfilmentByChannel"]
	OrderFulfilmentType string `json:"OrderFulfilmentType,omitempty"`

	// Order identifier tags
	OrderIdentifierTags []string `json:"OrderIdentifierTags"`

	// List of order items
	OrderItems []*ChannelOrderItem `json:"OrderItems"`

	// State the order should be saved e.g. hold, parked, none
	// Enum: ["None","Hold","Park"]
	OrderState string `json:"OrderState,omitempty"`

	// The raw status text of the order on the channel
	OrderStatus string `json:"OrderStatus,omitempty"`

	// The status of the order on the channel
	// Enum: ["Unknown","Pending","Unshipped","PartiallyShipped","Shipped","PartiallyCancelled","Cancelled","PartiallyRefunded","Refunded"]
	OrderStatusType string `json:"OrderStatusType,omitempty"`

	// Days after order is processed when PII data will get redacted - NULL/Not Supplied will never redact
	PIIRedactionDays int32 `json:"PIIRedactionDays,omitempty"`

	// Date the order was paid for
	// Format: date-time
	PaidOn strfmt.DateTime `json:"PaidOn,omitempty"`

	// Payment method name used for saving new payment methods
	PaymentMethodName string `json:"PaymentMethodName,omitempty"`

	// Payment status of the order, eg Paid
	// If Unpaid ChannelOrderAdapter.Save() will ensure order is PARKED
	// Enum: ["Unpaid","Paid","Cancelled"]
	PaymentStatus string `json:"PaymentStatus,omitempty"`

	// Postal service cost inclusive of tax after discount
	PostalServiceCost float64 `json:"PostalServiceCost,omitempty"`

	// Discount percent for the postal service cost, this will not calculate down the postal service cost
	PostalServiceDiscount float64 `json:"PostalServiceDiscount,omitempty"`

	// Postal service name used for saving new postal services
	PostalServiceName string `json:"PostalServiceName,omitempty"`

	// Tax percent for the postal service cost, eg 20
	PostalServiceTaxRate float64 `json:"PostalServiceTaxRate,omitempty"`

	// UTC received date/time of the order
	// Format: date-time
	ReceivedDate strfmt.DateTime `json:"ReceivedDate,omitempty"`

	// Reference number, should be the same as the one used for despatches
	ReferenceNumber string `json:"ReferenceNumber,omitempty"`

	// Determines wither or not to save payment methods if it does not exist
	SavePaymentMethodIfNotExist bool `json:"SavePaymentMethodIfNotExist,omitempty"`

	// Determines wither or not to save postal service if it does not exist
	SavePostalServiceIfNotExist bool `json:"SavePostalServiceIfNotExist,omitempty"`

	// Secondary reference number
	SecondaryReferenceNumber string `json:"SecondaryReferenceNumber,omitempty"`

	// The amount refunded for shipping (if known)
	ShippingRefund float64 `json:"ShippingRefund,omitempty"`

	// The known refund allocation for the order shipping
	// Enum: ["Unknown","OrderLevel","LineLevel","Both"]
	ShippingRefundAllocation string `json:"ShippingRefundAllocation,omitempty"`

	// Used to determine the site of the order.
	Site string `json:"Site,omitempty"`

	// Source
	Source string `json:"Source,omitempty"`

	// Overrides the mapping source for the channel in the instance that the order may have originally been downloaded with an alternative source value.
	SourceOverride string `json:"SourceOverride,omitempty"`

	// SubSource
	SubSource string `json:"SubSource,omitempty"`

	// The total refund amount applied to the order across all items, services and order-level refunds
	TotalRefund float64 `json:"TotalRefund,omitempty"`

	// UTC date/time the order was last updated at
	// Format: date-time
	UpdatedDate strfmt.DateTime `json:"UpdatedDate,omitempty"`

	// Validate if the tax should be overwritten on the order.
	UseChannelTax bool `json:"UseChannelTax,omitempty"`

	// Used when IsNew is false to update the order
	// Example: 00000000-0000-0000-0000-000000000000
	// Read Only: true
	// Format: uuid
	PkOrderID strfmt.UUID `json:"pkOrderId,omitempty"`
}

// Validate validates this channel order
func (m *ChannelOrder) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBillingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiscountTaxType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiscountType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDispatchBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExtendedProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLineRefundAllocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderFulfilmentType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderStatusType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaidOn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReceivedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShippingRefundAllocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePkOrderID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ChannelOrder) validateBillingAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.BillingAddress) { // not required
		return nil
	}

	if m.BillingAddress != nil {
		if err := m.BillingAddress.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("BillingAddress")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("BillingAddress")
			}

			return err
		}
	}

	return nil
}

func (m *ChannelOrder) validateDeliveryAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.DeliveryAddress) { // not required
		return nil
	}

	if m.DeliveryAddress != nil {
		if err := m.DeliveryAddress.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("DeliveryAddress")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("DeliveryAddress")
			}

			return err
		}
	}

	return nil
}

func (m *ChannelOrder) validateDeliveryEndDate(formats strfmt.Registry) error {
	if swag.IsZero(m.DeliveryEndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("DeliveryEndDate", "body", "date-time", m.DeliveryEndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ChannelOrder) validateDeliveryStartDate(formats strfmt.Registry) error {
	if swag.IsZero(m.DeliveryStartDate) { // not required
		return nil
	}

	if err := validate.FormatOf("DeliveryStartDate", "body", "date-time", m.DeliveryStartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var channelOrderTypeDiscountTaxTypePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DeductAfterTax","DeductBeforeTax"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		channelOrderTypeDiscountTaxTypePropEnum = append(channelOrderTypeDiscountTaxTypePropEnum, v)
	}
}

const (

	// ChannelOrderDiscountTaxTypeDeductAfterTax captures enum value "DeductAfterTax"
	ChannelOrderDiscountTaxTypeDeductAfterTax string = "DeductAfterTax"

	// ChannelOrderDiscountTaxTypeDeductBeforeTax captures enum value "DeductBeforeTax"
	ChannelOrderDiscountTaxTypeDeductBeforeTax string = "DeductBeforeTax"
)

// prop value enum
func (m *ChannelOrder) validateDiscountTaxTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, channelOrderTypeDiscountTaxTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChannelOrder) validateDiscountTaxType(formats strfmt.Registry) error {
	if swag.IsZero(m.DiscountTaxType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDiscountTaxTypeEnum("DiscountTaxType", "body", m.DiscountTaxType); err != nil {
		return err
	}

	return nil
}

var channelOrderTypeDiscountTypePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["AllEvenly","ItemsThenPostage","PostageThenItems"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		channelOrderTypeDiscountTypePropEnum = append(channelOrderTypeDiscountTypePropEnum, v)
	}
}

const (

	// ChannelOrderDiscountTypeAllEvenly captures enum value "AllEvenly"
	ChannelOrderDiscountTypeAllEvenly string = "AllEvenly"

	// ChannelOrderDiscountTypeItemsThenPostage captures enum value "ItemsThenPostage"
	ChannelOrderDiscountTypeItemsThenPostage string = "ItemsThenPostage"

	// ChannelOrderDiscountTypePostageThenItems captures enum value "PostageThenItems"
	ChannelOrderDiscountTypePostageThenItems string = "PostageThenItems"
)

// prop value enum
func (m *ChannelOrder) validateDiscountTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, channelOrderTypeDiscountTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChannelOrder) validateDiscountType(formats strfmt.Registry) error {
	if swag.IsZero(m.DiscountType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDiscountTypeEnum("DiscountType", "body", m.DiscountType); err != nil {
		return err
	}

	return nil
}

func (m *ChannelOrder) validateDispatchBy(formats strfmt.Registry) error {
	if swag.IsZero(m.DispatchBy) { // not required
		return nil
	}

	if err := validate.FormatOf("DispatchBy", "body", "date-time", m.DispatchBy.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ChannelOrder) validateExtendedProperties(formats strfmt.Registry) error {
	if swag.IsZero(m.ExtendedProperties) { // not required
		return nil
	}

	for i := 0; i < len(m.ExtendedProperties); i++ {
		if swag.IsZero(m.ExtendedProperties[i]) { // not required
			continue
		}

		if m.ExtendedProperties[i] != nil {
			if err := m.ExtendedProperties[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("ExtendedProperties" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("ExtendedProperties" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

var channelOrderTypeLineRefundAllocationPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Unknown","OrderLevel","LineLevel","Both"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		channelOrderTypeLineRefundAllocationPropEnum = append(channelOrderTypeLineRefundAllocationPropEnum, v)
	}
}

const (

	// ChannelOrderLineRefundAllocationUnknown captures enum value "Unknown"
	ChannelOrderLineRefundAllocationUnknown string = "Unknown"

	// ChannelOrderLineRefundAllocationOrderLevel captures enum value "OrderLevel"
	ChannelOrderLineRefundAllocationOrderLevel string = "OrderLevel"

	// ChannelOrderLineRefundAllocationLineLevel captures enum value "LineLevel"
	ChannelOrderLineRefundAllocationLineLevel string = "LineLevel"

	// ChannelOrderLineRefundAllocationBoth captures enum value "Both"
	ChannelOrderLineRefundAllocationBoth string = "Both"
)

// prop value enum
func (m *ChannelOrder) validateLineRefundAllocationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, channelOrderTypeLineRefundAllocationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChannelOrder) validateLineRefundAllocation(formats strfmt.Registry) error {
	if swag.IsZero(m.LineRefundAllocation) { // not required
		return nil
	}

	// value enum
	if err := m.validateLineRefundAllocationEnum("LineRefundAllocation", "body", m.LineRefundAllocation); err != nil {
		return err
	}

	return nil
}

func (m *ChannelOrder) validateLocations(formats strfmt.Registry) error {
	if swag.IsZero(m.Locations) { // not required
		return nil
	}

	for i := 0; i < len(m.Locations); i++ {
		if swag.IsZero(m.Locations[i]) { // not required
			continue
		}

		if m.Locations[i] != nil {
			if err := m.Locations[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Locations" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Locations" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *ChannelOrder) validateNotes(formats strfmt.Registry) error {
	if swag.IsZero(m.Notes) { // not required
		return nil
	}

	for i := 0; i < len(m.Notes); i++ {
		if swag.IsZero(m.Notes[i]) { // not required
			continue
		}

		if m.Notes[i] != nil {
			if err := m.Notes[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Notes" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Notes" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

var channelOrderTypeOrderFulfilmentTypePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Manual","POS","DigitalOnly","FulfilmentByChannel"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		channelOrderTypeOrderFulfilmentTypePropEnum = append(channelOrderTypeOrderFulfilmentTypePropEnum, v)
	}
}

const (

	// ChannelOrderOrderFulfilmentTypeManual captures enum value "Manual"
	ChannelOrderOrderFulfilmentTypeManual string = "Manual"

	// ChannelOrderOrderFulfilmentTypePOS captures enum value "POS"
	ChannelOrderOrderFulfilmentTypePOS string = "POS"

	// ChannelOrderOrderFulfilmentTypeDigitalOnly captures enum value "DigitalOnly"
	ChannelOrderOrderFulfilmentTypeDigitalOnly string = "DigitalOnly"

	// ChannelOrderOrderFulfilmentTypeFulfilmentByChannel captures enum value "FulfilmentByChannel"
	ChannelOrderOrderFulfilmentTypeFulfilmentByChannel string = "FulfilmentByChannel"
)

// prop value enum
func (m *ChannelOrder) validateOrderFulfilmentTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, channelOrderTypeOrderFulfilmentTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChannelOrder) validateOrderFulfilmentType(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderFulfilmentType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOrderFulfilmentTypeEnum("OrderFulfilmentType", "body", m.OrderFulfilmentType); err != nil {
		return err
	}

	return nil
}

func (m *ChannelOrder) validateOrderItems(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderItems) { // not required
		return nil
	}

	for i := 0; i < len(m.OrderItems); i++ {
		if swag.IsZero(m.OrderItems[i]) { // not required
			continue
		}

		if m.OrderItems[i] != nil {
			if err := m.OrderItems[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("OrderItems" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("OrderItems" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

var channelOrderTypeOrderStatePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","Hold","Park"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		channelOrderTypeOrderStatePropEnum = append(channelOrderTypeOrderStatePropEnum, v)
	}
}

const (

	// ChannelOrderOrderStateNone captures enum value "None"
	ChannelOrderOrderStateNone string = "None"

	// ChannelOrderOrderStateHold captures enum value "Hold"
	ChannelOrderOrderStateHold string = "Hold"

	// ChannelOrderOrderStatePark captures enum value "Park"
	ChannelOrderOrderStatePark string = "Park"
)

// prop value enum
func (m *ChannelOrder) validateOrderStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, channelOrderTypeOrderStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChannelOrder) validateOrderState(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOrderStateEnum("OrderState", "body", m.OrderState); err != nil {
		return err
	}

	return nil
}

var channelOrderTypeOrderStatusTypePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Unknown","Pending","Unshipped","PartiallyShipped","Shipped","PartiallyCancelled","Cancelled","PartiallyRefunded","Refunded"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		channelOrderTypeOrderStatusTypePropEnum = append(channelOrderTypeOrderStatusTypePropEnum, v)
	}
}

const (

	// ChannelOrderOrderStatusTypeUnknown captures enum value "Unknown"
	ChannelOrderOrderStatusTypeUnknown string = "Unknown"

	// ChannelOrderOrderStatusTypePending captures enum value "Pending"
	ChannelOrderOrderStatusTypePending string = "Pending"

	// ChannelOrderOrderStatusTypeUnshipped captures enum value "Unshipped"
	ChannelOrderOrderStatusTypeUnshipped string = "Unshipped"

	// ChannelOrderOrderStatusTypePartiallyShipped captures enum value "PartiallyShipped"
	ChannelOrderOrderStatusTypePartiallyShipped string = "PartiallyShipped"

	// ChannelOrderOrderStatusTypeShipped captures enum value "Shipped"
	ChannelOrderOrderStatusTypeShipped string = "Shipped"

	// ChannelOrderOrderStatusTypePartiallyCancelled captures enum value "PartiallyCancelled"
	ChannelOrderOrderStatusTypePartiallyCancelled string = "PartiallyCancelled"

	// ChannelOrderOrderStatusTypeCancelled captures enum value "Cancelled"
	ChannelOrderOrderStatusTypeCancelled string = "Cancelled"

	// ChannelOrderOrderStatusTypePartiallyRefunded captures enum value "PartiallyRefunded"
	ChannelOrderOrderStatusTypePartiallyRefunded string = "PartiallyRefunded"

	// ChannelOrderOrderStatusTypeRefunded captures enum value "Refunded"
	ChannelOrderOrderStatusTypeRefunded string = "Refunded"
)

// prop value enum
func (m *ChannelOrder) validateOrderStatusTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, channelOrderTypeOrderStatusTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChannelOrder) validateOrderStatusType(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderStatusType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOrderStatusTypeEnum("OrderStatusType", "body", m.OrderStatusType); err != nil {
		return err
	}

	return nil
}

func (m *ChannelOrder) validatePaidOn(formats strfmt.Registry) error {
	if swag.IsZero(m.PaidOn) { // not required
		return nil
	}

	if err := validate.FormatOf("PaidOn", "body", "date-time", m.PaidOn.String(), formats); err != nil {
		return err
	}

	return nil
}

var channelOrderTypePaymentStatusPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Unpaid","Paid","Cancelled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		channelOrderTypePaymentStatusPropEnum = append(channelOrderTypePaymentStatusPropEnum, v)
	}
}

const (

	// ChannelOrderPaymentStatusUnpaid captures enum value "Unpaid"
	ChannelOrderPaymentStatusUnpaid string = "Unpaid"

	// ChannelOrderPaymentStatusPaid captures enum value "Paid"
	ChannelOrderPaymentStatusPaid string = "Paid"

	// ChannelOrderPaymentStatusCancelled captures enum value "Cancelled"
	ChannelOrderPaymentStatusCancelled string = "Cancelled"
)

// prop value enum
func (m *ChannelOrder) validatePaymentStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, channelOrderTypePaymentStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChannelOrder) validatePaymentStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validatePaymentStatusEnum("PaymentStatus", "body", m.PaymentStatus); err != nil {
		return err
	}

	return nil
}

func (m *ChannelOrder) validateReceivedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ReceivedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("ReceivedDate", "body", "date-time", m.ReceivedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var channelOrderTypeShippingRefundAllocationPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Unknown","OrderLevel","LineLevel","Both"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		channelOrderTypeShippingRefundAllocationPropEnum = append(channelOrderTypeShippingRefundAllocationPropEnum, v)
	}
}

const (

	// ChannelOrderShippingRefundAllocationUnknown captures enum value "Unknown"
	ChannelOrderShippingRefundAllocationUnknown string = "Unknown"

	// ChannelOrderShippingRefundAllocationOrderLevel captures enum value "OrderLevel"
	ChannelOrderShippingRefundAllocationOrderLevel string = "OrderLevel"

	// ChannelOrderShippingRefundAllocationLineLevel captures enum value "LineLevel"
	ChannelOrderShippingRefundAllocationLineLevel string = "LineLevel"

	// ChannelOrderShippingRefundAllocationBoth captures enum value "Both"
	ChannelOrderShippingRefundAllocationBoth string = "Both"
)

// prop value enum
func (m *ChannelOrder) validateShippingRefundAllocationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, channelOrderTypeShippingRefundAllocationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChannelOrder) validateShippingRefundAllocation(formats strfmt.Registry) error {
	if swag.IsZero(m.ShippingRefundAllocation) { // not required
		return nil
	}

	// value enum
	if err := m.validateShippingRefundAllocationEnum("ShippingRefundAllocation", "body", m.ShippingRefundAllocation); err != nil {
		return err
	}

	return nil
}

func (m *ChannelOrder) validateUpdatedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("UpdatedDate", "body", "date-time", m.UpdatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ChannelOrder) validatePkOrderID(formats strfmt.Registry) error {
	if swag.IsZero(m.PkOrderID) { // not required
		return nil
	}

	if err := validate.FormatOf("pkOrderId", "body", "uuid", m.PkOrderID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this channel order based on the context it is used
func (m *ChannelOrder) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBillingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDeliveryAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExtendedProperties(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNotes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrderItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePkOrderID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ChannelOrder) contextValidateBillingAddress(ctx context.Context, formats strfmt.Registry) error {

	if m.BillingAddress != nil {

		if swag.IsZero(m.BillingAddress) { // not required
			return nil
		}

		if err := m.BillingAddress.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("BillingAddress")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("BillingAddress")
			}

			return err
		}
	}

	return nil
}

func (m *ChannelOrder) contextValidateDeliveryAddress(ctx context.Context, formats strfmt.Registry) error {

	if m.DeliveryAddress != nil {

		if swag.IsZero(m.DeliveryAddress) { // not required
			return nil
		}

		if err := m.DeliveryAddress.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("DeliveryAddress")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("DeliveryAddress")
			}

			return err
		}
	}

	return nil
}

func (m *ChannelOrder) contextValidateExtendedProperties(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExtendedProperties); i++ {

		if m.ExtendedProperties[i] != nil {

			if swag.IsZero(m.ExtendedProperties[i]) { // not required
				return nil
			}

			if err := m.ExtendedProperties[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("ExtendedProperties" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("ExtendedProperties" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *ChannelOrder) contextValidateLocations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Locations); i++ {

		if m.Locations[i] != nil {

			if swag.IsZero(m.Locations[i]) { // not required
				return nil
			}

			if err := m.Locations[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Locations" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Locations" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *ChannelOrder) contextValidateNotes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Notes); i++ {

		if m.Notes[i] != nil {

			if swag.IsZero(m.Notes[i]) { // not required
				return nil
			}

			if err := m.Notes[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("Notes" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("Notes" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *ChannelOrder) contextValidateOrderItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OrderItems); i++ {

		if m.OrderItems[i] != nil {

			if swag.IsZero(m.OrderItems[i]) { // not required
				return nil
			}

			if err := m.OrderItems[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("OrderItems" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("OrderItems" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *ChannelOrder) contextValidatePkOrderID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "pkOrderId", "body", m.PkOrderID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ChannelOrder) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ChannelOrder) UnmarshalBinary(b []byte) error {
	var res ChannelOrder
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
